/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports, module2) {
    module2.exports = function isBuffer2(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
  }
});

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module2) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject2 = function isPlainObject3(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module2.exports = function extend2() {
      var options, name, src, copy, copyIsArray, clone;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray(src) ? src : [];
                } else {
                  clone = src && isPlainObject2(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend2(deep, clone, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/pluralize/pluralize.js
var require_pluralize = __commonJS({
  "node_modules/pluralize/pluralize.js"(exports, module2) {
    (function(root, pluralize2) {
      if (typeof require === "function" && typeof exports === "object" && typeof module2 === "object") {
        module2.exports = pluralize2();
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return pluralize2();
        });
      } else {
        root.pluralize = pluralize2();
      }
    })(exports, function() {
      var pluralRules = [];
      var singularRules = [];
      var uncountables = {};
      var irregularPlurals = {};
      var irregularSingles = {};
      function sanitizeRule(rule) {
        if (typeof rule === "string") {
          return new RegExp("^" + rule + "$", "i");
        }
        return rule;
      }
      function restoreCase(word2, token) {
        if (word2 === token)
          return token;
        if (word2 === word2.toLowerCase())
          return token.toLowerCase();
        if (word2 === word2.toUpperCase())
          return token.toUpperCase();
        if (word2[0] === word2[0].toUpperCase()) {
          return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();
        }
        return token.toLowerCase();
      }
      function interpolate(str, args) {
        return str.replace(/\$(\d{1,2})/g, function(match, index2) {
          return args[index2] || "";
        });
      }
      function replace(word2, rule) {
        return word2.replace(rule[0], function(match, index2) {
          var result = interpolate(rule[1], arguments);
          if (match === "") {
            return restoreCase(word2[index2 - 1], result);
          }
          return restoreCase(match, result);
        });
      }
      function sanitizeWord(token, word2, rules) {
        if (!token.length || uncountables.hasOwnProperty(token)) {
          return word2;
        }
        var len = rules.length;
        while (len--) {
          var rule = rules[len];
          if (rule[0].test(word2))
            return replace(word2, rule);
        }
        return word2;
      }
      function replaceWord(replaceMap, keepMap, rules) {
        return function(word2) {
          var token = word2.toLowerCase();
          if (keepMap.hasOwnProperty(token)) {
            return restoreCase(word2, token);
          }
          if (replaceMap.hasOwnProperty(token)) {
            return restoreCase(word2, replaceMap[token]);
          }
          return sanitizeWord(token, word2, rules);
        };
      }
      function checkWord(replaceMap, keepMap, rules, bool) {
        return function(word2) {
          var token = word2.toLowerCase();
          if (keepMap.hasOwnProperty(token))
            return true;
          if (replaceMap.hasOwnProperty(token))
            return false;
          return sanitizeWord(token, token, rules) === token;
        };
      }
      function pluralize2(word2, count, inclusive) {
        var pluralized = count === 1 ? pluralize2.singular(word2) : pluralize2.plural(word2);
        return (inclusive ? count + " " : "") + pluralized;
      }
      pluralize2.plural = replaceWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.isPlural = checkWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.singular = replaceWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.isSingular = checkWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.addPluralRule = function(rule, replacement) {
        pluralRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize2.addSingularRule = function(rule, replacement) {
        singularRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize2.addUncountableRule = function(word2) {
        if (typeof word2 === "string") {
          uncountables[word2.toLowerCase()] = true;
          return;
        }
        pluralize2.addPluralRule(word2, "$0");
        pluralize2.addSingularRule(word2, "$0");
      };
      pluralize2.addIrregularRule = function(single2, plural) {
        plural = plural.toLowerCase();
        single2 = single2.toLowerCase();
        irregularSingles[single2] = plural;
        irregularPlurals[plural] = single2;
      };
      [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["passerby", "passersby"]
      ].forEach(function(rule) {
        return pluralize2.addIrregularRule(rule[0], rule[1]);
      });
      [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(rule) {
        return pluralize2.addPluralRule(rule[0], rule[1]);
      });
      [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
        [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
        [/(test)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(rule) {
        return pluralize2.addSingularRule(rule[0], rule[1]);
      });
      [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[eé]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        // "chinese", "japanese"
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /measles$/i,
        /o[iu]s$/i,
        // "carnivorous"
        /pox$/i,
        // "chickpox", "smallpox"
        /sheep$/i
      ].forEach(pluralize2.addUncountableRule);
      return pluralize2;
    });
  }
});

// node_modules/normalize-strings/charmap.json
var require_charmap = __commonJS({
  "node_modules/normalize-strings/charmap.json"(exports, module2) {
    module2.exports = { "105": "i", "192": "A", "193": "A", "194": "A", "195": "A", "196": "A", "197": "A", "199": "C", "200": "E", "201": "E", "202": "E", "203": "E", "204": "I", "205": "I", "206": "I", "207": "I", "209": "N", "210": "O", "211": "O", "212": "O", "213": "O", "214": "O", "216": "O", "217": "U", "218": "U", "219": "U", "220": "U", "221": "Y", "224": "a", "225": "a", "226": "a", "227": "a", "228": "a", "229": "a", "231": "c", "232": "e", "233": "e", "234": "e", "235": "e", "236": "i", "237": "i", "238": "i", "239": "i", "241": "n", "242": "o", "243": "o", "244": "o", "245": "o", "246": "o", "248": "o", "249": "u", "250": "u", "251": "u", "252": "u", "253": "y", "255": "y", "256": "A", "257": "a", "258": "A", "259": "a", "260": "A", "261": "a", "262": "C", "263": "c", "264": "C", "265": "c", "266": "C", "267": "c", "268": "C", "269": "c", "270": "D", "271": "d", "272": "D", "273": "d", "274": "E", "275": "e", "276": "E", "277": "e", "278": "E", "279": "e", "280": "E", "281": "e", "282": "E", "283": "e", "284": "G", "285": "g", "286": "G", "287": "g", "288": "G", "289": "g", "290": "G", "291": "g", "292": "H", "293": "h", "294": "H", "295": "h", "296": "I", "297": "i", "298": "I", "299": "i", "300": "I", "301": "i", "302": "I", "303": "i", "304": "I", "308": "J", "309": "j", "310": "K", "311": "k", "313": "L", "314": "l", "315": "L", "316": "l", "317": "L", "318": "l", "319": "L", "320": "l", "321": "L", "322": "l", "323": "N", "324": "n", "325": "N", "326": "n", "327": "N", "328": "n", "332": "O", "333": "o", "334": "O", "335": "o", "336": "O", "337": "o", "338": "O", "339": "o", "340": "R", "341": "r", "342": "R", "343": "r", "344": "R", "345": "r", "346": "S", "347": "s", "348": "S", "349": "s", "350": "S", "351": "s", "352": "S", "353": "s", "354": "T", "355": "t", "356": "T", "357": "t", "358": "T", "359": "t", "360": "U", "361": "u", "362": "U", "363": "u", "364": "U", "365": "u", "366": "U", "367": "u", "368": "U", "369": "u", "370": "U", "371": "u", "372": "W", "373": "w", "374": "Y", "375": "y", "376": "Y", "377": "Z", "378": "z", "379": "Z", "380": "z", "381": "Z", "382": "z", "384": "b", "385": "B", "386": "B", "387": "b", "390": "O", "391": "C", "392": "c", "393": "D", "394": "D", "395": "D", "396": "d", "398": "E", "400": "E", "401": "F", "402": "f", "403": "G", "407": "I", "408": "K", "409": "k", "410": "l", "412": "M", "413": "N", "414": "n", "415": "O", "416": "O", "417": "o", "420": "P", "421": "p", "422": "R", "427": "t", "428": "T", "429": "t", "430": "T", "431": "U", "432": "u", "434": "V", "435": "Y", "436": "y", "437": "Z", "438": "z", "461": "A", "462": "a", "463": "I", "464": "i", "465": "O", "466": "o", "467": "U", "468": "u", "477": "e", "484": "G", "485": "g", "486": "G", "487": "g", "488": "K", "489": "k", "490": "O", "491": "o", "500": "G", "501": "g", "504": "N", "505": "n", "512": "A", "513": "a", "514": "A", "515": "a", "516": "E", "517": "e", "518": "E", "519": "e", "520": "I", "521": "i", "522": "I", "523": "i", "524": "O", "525": "o", "526": "O", "527": "o", "528": "R", "529": "r", "530": "R", "531": "r", "532": "U", "533": "u", "534": "U", "535": "u", "536": "S", "537": "s", "538": "T", "539": "t", "542": "H", "543": "h", "544": "N", "545": "d", "548": "Z", "549": "z", "550": "A", "551": "a", "552": "E", "553": "e", "558": "O", "559": "o", "562": "Y", "563": "y", "564": "l", "565": "n", "566": "t", "567": "j", "570": "A", "571": "C", "572": "c", "573": "L", "574": "T", "575": "s", "576": "z", "579": "B", "580": "U", "581": "V", "582": "E", "583": "e", "584": "J", "585": "j", "586": "Q", "587": "q", "588": "R", "589": "r", "590": "Y", "591": "y", "592": "a", "593": "a", "595": "b", "596": "o", "597": "c", "598": "d", "599": "d", "600": "e", "603": "e", "604": "e", "605": "e", "606": "e", "607": "j", "608": "g", "609": "g", "610": "g", "613": "h", "614": "h", "616": "i", "618": "i", "619": "l", "620": "l", "621": "l", "623": "m", "624": "m", "625": "m", "626": "n", "627": "n", "628": "n", "629": "o", "633": "r", "634": "r", "635": "r", "636": "r", "637": "r", "638": "r", "639": "r", "640": "r", "641": "r", "642": "s", "647": "t", "648": "t", "649": "u", "651": "v", "652": "v", "653": "w", "654": "y", "655": "y", "656": "z", "657": "z", "663": "c", "665": "b", "666": "e", "667": "g", "668": "h", "669": "j", "670": "k", "671": "l", "672": "q", "686": "h", "688": "h", "690": "j", "691": "r", "692": "r", "694": "r", "695": "w", "696": "y", "737": "l", "738": "s", "739": "x", "780": "v", "829": "x", "851": "x", "867": "a", "868": "e", "869": "i", "870": "o", "871": "u", "872": "c", "873": "d", "874": "h", "875": "m", "876": "r", "877": "t", "878": "v", "879": "x", "7424": "a", "7427": "b", "7428": "c", "7429": "d", "7431": "e", "7432": "e", "7433": "i", "7434": "j", "7435": "k", "7436": "l", "7437": "m", "7438": "n", "7439": "o", "7440": "o", "7441": "o", "7442": "o", "7443": "o", "7446": "o", "7447": "o", "7448": "p", "7449": "r", "7450": "r", "7451": "t", "7452": "u", "7453": "u", "7454": "u", "7455": "m", "7456": "v", "7457": "w", "7458": "z", "7522": "i", "7523": "r", "7524": "u", "7525": "v", "7680": "A", "7681": "a", "7682": "B", "7683": "b", "7684": "B", "7685": "b", "7686": "B", "7687": "b", "7690": "D", "7691": "d", "7692": "D", "7693": "d", "7694": "D", "7695": "d", "7696": "D", "7697": "d", "7698": "D", "7699": "d", "7704": "E", "7705": "e", "7706": "E", "7707": "e", "7710": "F", "7711": "f", "7712": "G", "7713": "g", "7714": "H", "7715": "h", "7716": "H", "7717": "h", "7718": "H", "7719": "h", "7720": "H", "7721": "h", "7722": "H", "7723": "h", "7724": "I", "7725": "i", "7728": "K", "7729": "k", "7730": "K", "7731": "k", "7732": "K", "7733": "k", "7734": "L", "7735": "l", "7738": "L", "7739": "l", "7740": "L", "7741": "l", "7742": "M", "7743": "m", "7744": "M", "7745": "m", "7746": "M", "7747": "m", "7748": "N", "7749": "n", "7750": "N", "7751": "n", "7752": "N", "7753": "n", "7754": "N", "7755": "n", "7764": "P", "7765": "p", "7766": "P", "7767": "p", "7768": "R", "7769": "r", "7770": "R", "7771": "r", "7774": "R", "7775": "r", "7776": "S", "7777": "s", "7778": "S", "7779": "s", "7786": "T", "7787": "t", "7788": "T", "7789": "t", "7790": "T", "7791": "t", "7792": "T", "7793": "t", "7794": "U", "7795": "u", "7796": "U", "7797": "u", "7798": "U", "7799": "u", "7804": "V", "7805": "v", "7806": "V", "7807": "v", "7808": "W", "7809": "w", "7810": "W", "7811": "w", "7812": "W", "7813": "w", "7814": "W", "7815": "w", "7816": "W", "7817": "w", "7818": "X", "7819": "x", "7820": "X", "7821": "x", "7822": "Y", "7823": "y", "7824": "Z", "7825": "z", "7826": "Z", "7827": "z", "7828": "Z", "7829": "z", "7835": "s", "7840": "A", "7841": "a", "7842": "A", "7843": "a", "7864": "E", "7865": "e", "7866": "E", "7867": "e", "7868": "E", "7869": "e", "7880": "I", "7881": "i", "7882": "I", "7883": "i", "7884": "O", "7885": "o", "7886": "O", "7887": "o", "7908": "U", "7909": "u", "7910": "U", "7911": "u", "7922": "Y", "7923": "y", "7924": "Y", "7925": "y", "7926": "Y", "7927": "y", "7928": "Y", "7929": "y", "8305": "i", "8341": "h", "8342": "k", "8343": "l", "8344": "m", "8345": "n", "8346": "p", "8347": "s", "8348": "t", "8450": "c", "8458": "g", "8459": "h", "8460": "h", "8461": "h", "8464": "i", "8465": "i", "8466": "l", "8467": "l", "8468": "l", "8469": "n", "8472": "p", "8473": "p", "8474": "q", "8475": "r", "8476": "r", "8477": "r", "8484": "z", "8488": "z", "8492": "b", "8493": "c", "8495": "e", "8496": "e", "8497": "f", "8498": "F", "8499": "m", "8500": "o", "8506": "q", "8513": "g", "8514": "l", "8515": "l", "8516": "y", "8517": "d", "8518": "d", "8519": "e", "8520": "i", "8521": "j", "8526": "f", "8579": "C", "8580": "c", "8765": "s", "8766": "s", "8959": "z", "8999": "x", "9746": "x", "9776": "i", "9866": "i", "10005": "x", "10006": "x", "10007": "x", "10008": "x", "10625": "z", "10626": "z", "11362": "L", "11364": "R", "11365": "a", "11366": "t", "11373": "A", "11374": "M", "11375": "A", "11390": "S", "11391": "Z", "19904": "i", "42893": "H", "42922": "H", "42923": "E", "42924": "G", "42925": "L", "42928": "K", "42929": "T", "62937": "x" };
  }
});

// node_modules/normalize-strings/index.js
var require_normalize_strings = __commonJS({
  "node_modules/normalize-strings/index.js"(exports, module2) {
    (function(global, factory) {
      if (typeof define === "function" && define.amd) {
        define(function() {
          return factory(global, global.document);
        });
      } else if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = factory(global, global.document);
      } else {
        global.normalize = factory(global, global.document);
      }
    })(typeof window !== "undefined" ? window : exports, function(window2, document2) {
      var charmap = require_charmap();
      var regex = null;
      var current_charmap;
      var old_charmap;
      function normalize4(str, custom_charmap) {
        old_charmap = current_charmap;
        current_charmap = custom_charmap || charmap;
        regex = regex && old_charmap === current_charmap ? regex : buildRegExp(current_charmap);
        return str.replace(regex, function(charToReplace) {
          return current_charmap[charToReplace.charCodeAt(0)] || charToReplace;
        });
      }
      function buildRegExp(charmap2) {
        return new RegExp("[" + Object.keys(charmap2).map(function(code) {
          return String.fromCharCode(code);
        }).join(" ") + "]", "g");
      }
      return normalize4;
    });
  }
});

// node_modules/parse-english/node_modules/nlcst-to-string/index.js
var require_nlcst_to_string = __commonJS({
  "node_modules/parse-english/node_modules/nlcst-to-string/index.js"(exports, module2) {
    "use strict";
    module2.exports = nlcstToString;
    function nlcstToString(node, separator) {
      var sep = separator || "";
      var values;
      var length;
      var children;
      if (!node || !("length" in node) && !node.type) {
        throw new Error("Expected node, not `" + node + "`");
      }
      if (typeof node.value === "string") {
        return node.value;
      }
      children = "length" in node ? node : node.children;
      length = children.length;
      if (length === 1 && "value" in children[0]) {
        return children[0].value;
      }
      values = [];
      while (length--) {
        values[length] = nlcstToString(children[length], sep);
      }
      return values.join(sep);
    }
  }
});

// node_modules/parse-english/node_modules/unist-util-visit-children/index.js
var require_unist_util_visit_children = __commonJS({
  "node_modules/parse-english/node_modules/unist-util-visit-children/index.js"(exports, module2) {
    "use strict";
    module2.exports = visitChildren3;
    function visitChildren3(callback) {
      return visitor;
      function visitor(parent) {
        var index2 = -1;
        var children = parent && parent.children;
        if (!children) {
          throw new Error("Missing children in `parent` for `visitor`");
        }
        while (++index2 in children) {
          callback(children[index2], index2, parent);
        }
      }
    }
  }
});

// node_modules/parse-english/node_modules/array-iterate/index.js
var require_array_iterate = __commonJS({
  "node_modules/parse-english/node_modules/array-iterate/index.js"(exports, module2) {
    "use strict";
    module2.exports = iterate;
    var own6 = {}.hasOwnProperty;
    function iterate(values, callback, context) {
      var index2 = -1;
      var result;
      if (!values) {
        throw new Error("Iterate requires that |this| not be " + values);
      }
      if (!own6.call(values, "length")) {
        throw new Error("Iterate requires that |this| has a `length`");
      }
      if (typeof callback !== "function") {
        throw new Error("`callback` must be a function");
      }
      while (++index2 < values.length) {
        if (!(index2 in values)) {
          continue;
        }
        result = callback.call(context, values[index2], index2, values);
        if (typeof result === "number") {
          if (result < 0) {
            index2 = 0;
          }
          index2 = result - 1;
        }
      }
    }
  }
});

// node_modules/parse-english/node_modules/unist-util-modify-children/index.js
var require_unist_util_modify_children = __commonJS({
  "node_modules/parse-english/node_modules/unist-util-modify-children/index.js"(exports, module2) {
    "use strict";
    var iterate = require_array_iterate();
    module2.exports = modifierFactory;
    function modifierFactory(callback) {
      return iteratorFactory(wrapperFactory(callback));
    }
    function iteratorFactory(callback) {
      return iterator;
      function iterator(parent) {
        var children = parent && parent.children;
        if (!children) {
          throw new Error("Missing children in `parent` for `modifier`");
        }
        iterate(children, callback, parent);
      }
    }
    function wrapperFactory(callback) {
      return wrapper;
      function wrapper(value, index2) {
        return callback(value, index2, this);
      }
    }
  }
});

// src/plugin/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RedPenPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");

// node_modules/bail/index.js
function bail(error) {
  if (error) {
    throw error;
  }
}

// node_modules/unified/lib/index.js
var import_is_buffer2 = __toESM(require_is_buffer(), 1);
var import_extend = __toESM(require_extend(), 1);

// node_modules/is-plain-obj/index.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/trough/index.js
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values);
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index2 < values.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values[index2];
        }
      }
      values = output;
      if (fn) {
        wrap(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = (
        /** @type {Error} */
        error
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result instanceof Promise) {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}

// node_modules/vfile/lib/index.js
var import_is_buffer = __toESM(require_is_buffer(), 1);

// node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point(value);
  }
  return "";
}
function point(point3) {
  return index(point3 && point3.line) + ":" + index(point3 && point3.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}

// node_modules/vfile-message/lib/index.js
var VFileMessage = class extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   > 👉 **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(reason, place, origin2) {
    const parts = [null, null];
    let position3 = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: { line: null, column: null },
      // @ts-expect-error: "
      end: { line: null, column: null }
    };
    super();
    if (typeof place === "string") {
      origin2 = place;
      place = void 0;
    }
    if (typeof origin2 === "string") {
      const index2 = origin2.indexOf(":");
      if (index2 === -1) {
        parts[1] = origin2;
      } else {
        parts[0] = origin2.slice(0, index2);
        parts[1] = origin2.slice(index2 + 1);
      }
    }
    if (place) {
      if ("type" in place || "position" in place) {
        if (place.position) {
          position3 = place.position;
        }
      } else if ("start" in place || "end" in place) {
        position3 = place;
      } else if ("line" in place || "column" in place) {
        position3.start = place;
      }
    }
    this.name = stringifyPosition(place) || "1:1";
    this.message = typeof reason === "object" ? reason.message : reason;
    this.stack = "";
    if (typeof reason === "object" && reason.stack) {
      this.stack = reason.stack;
    }
    this.reason = this.message;
    this.fatal;
    this.line = position3.start.line;
    this.column = position3.start.column;
    this.position = position3;
    this.source = parts[0];
    this.ruleId = parts[1];
    this.file;
    this.actual;
    this.expected;
    this.url;
    this.note;
  }
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.fatal = null;
VFileMessage.prototype.column = null;
VFileMessage.prototype.line = null;
VFileMessage.prototype.source = null;
VFileMessage.prototype.ruleId = null;
VFileMessage.prototype.position = null;

// node_modules/vfile/lib/minpath.browser.js
var path = { basename, dirname, extname, join, sep: "/" };
function basename(path2, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path2);
  let start = 0;
  let end = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
    while (index2--) {
      if (path2.charCodeAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path2.slice(start, end);
  }
  if (ext === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index2--) {
    if (path2.charCodeAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path2.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            end = index2;
          }
        } else {
          extIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path2.length;
  }
  return path2.slice(start, end);
}
function dirname(path2) {
  assertPath(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.charCodeAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path2.charCodeAt(0) === 47 ? "/" : "." : end === 1 && path2.charCodeAt(0) === 47 ? "//" : path2.slice(0, end);
}
function extname(path2) {
  assertPath(path2);
  let index2 = path2.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code = path2.charCodeAt(index2);
    if (code === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize(joined);
}
function normalize(path2) {
  assertPath(path2);
  const absolute = path2.charCodeAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.charCodeAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code = path2.charCodeAt(index2);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === index2 - 1 || dots === 1) {
      } else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}

// node_modules/vfile/lib/minproc.browser.js
var proc = { cwd };
function cwd() {
  return "/";
}

// node_modules/vfile/lib/minurl.shared.js
function isUrl(fileUrlOrPath) {
  return fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && // @ts-expect-error: indexable.
  fileUrlOrPath.href && // @ts-expect-error: indexable.
  fileUrlOrPath.origin;
}

// node_modules/vfile/lib/minurl.browser.js
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error.code = "ERR_INVALID_ARG_TYPE";
    throw error;
  }
  if (path2.protocol !== "file:") {
    const error = new TypeError("The URL must be of scheme file");
    error.code = "ERR_INVALID_URL_SCHEME";
    throw error;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url5) {
  if (url5.hostname !== "") {
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = "ERR_INVALID_FILE_URL_HOST";
    throw error;
  }
  const pathname = url5.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.charCodeAt(index2) === 37 && pathname.charCodeAt(index2 + 1) === 50) {
      const third = pathname.charCodeAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error.code = "ERR_INVALID_FILE_URL_PATH";
        throw error;
      }
    }
  }
  return decodeURIComponent(pathname);
}

// node_modules/vfile/lib/index.js
var order = ["history", "path", "basename", "stem", "extname", "dirname"];
var VFile = class {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Buffer` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (typeof value === "string" || buffer(value)) {
      options = { value };
    } else if (isUrl(value)) {
      options = { path: value };
    } else {
      options = value;
    }
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = proc.cwd();
    this.value;
    this.stored;
    this.result;
    this.map;
    let index2 = -1;
    while (++index2 < order.length) {
      const prop2 = order[index2];
      if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
      }
    }
    let prop;
    for (prop in options) {
      if (!order.includes(prop)) {
        this[prop] = options[prop];
      }
    }
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {string | URL} path
   */
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path === "string" ? path.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   */
  set dirname(dirname2) {
    assertPath2(this.basename, "dirname");
    this.path = path.join(dirname2 || "", this.basename);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path === "string" ? path.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = path.join(this.dirname || "", basename2);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path === "string" ? path.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath2(this.dirname, "extname");
    if (extname2) {
      if (extname2.charCodeAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path === "string" ? path.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = path.join(this.dirname || "", stem + (this.extname || ""));
  }
  /**
   * Serialize the file.
   *
   * @param {BufferEncoding | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Buffer`
   *   (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    return (this.value || "").toString(encoding || void 0);
  }
  /**
   * Create a warning message associated with the file.
   *
   * Its `fatal` is set to `false` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(reason, place, origin2) {
    const message = new VFileMessage(reason, place, origin2);
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Create an info message associated with the file.
   *
   * Its `fatal` is set to `null` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(reason, place, origin2) {
    const message = this.message(reason, place, origin2);
    message.fatal = null;
    return message;
  }
  /**
   * Create a fatal error associated with the file.
   *
   * Its `fatal` is set to `true` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * > 👉 **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Message.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(reason, place, origin2) {
    const message = this.message(reason, place, origin2);
    message.fatal = true;
    throw message;
  }
};
function assertPart(part, name) {
  if (part && part.includes(path.sep)) {
    throw new Error(
      "`" + name + "` cannot be a path: did not expect `" + path.sep + "`"
    );
  }
}
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath2(path2, name) {
  if (!path2) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
function buffer(value) {
  return (0, import_is_buffer.default)(value);
}

// node_modules/unified/lib/index.js
var unified = base().freeze();
var own = {}.hasOwnProperty;
function base() {
  const transformers = trough();
  const attachers = [];
  let namespace = {};
  let frozen;
  let freezeIndex = -1;
  processor.data = data;
  processor.Parser = void 0;
  processor.Compiler = void 0;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse;
  processor.stringify = stringify;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process;
  processor.processSync = processSync;
  return processor;
  function processor() {
    const destination = base();
    let index2 = -1;
    while (++index2 < attachers.length) {
      destination.use(...attachers[index2]);
    }
    destination.data((0, import_extend.default)(true, {}, namespace));
    return destination;
  }
  function data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", frozen);
        namespace[key] = value;
        return processor;
      }
      return own.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      assertUnfrozen("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function freeze() {
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      const [attacher, ...options] = attachers[freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(processor, ...options);
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Number.POSITIVE_INFINITY;
    return processor;
  }
  function use(value, ...options) {
    let settings;
    assertUnfrozen("use", frozen);
    if (value === null || value === void 0) {
    } else if (typeof value === "function") {
      addPlugin(value, ...options);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    if (settings) {
      namespace.settings = Object.assign(namespace.settings || {}, settings);
    }
    return processor;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...options2] = value2;
          addPlugin(plugin, ...options2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = Object.assign(settings || {}, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0) {
      } else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value2) {
      let index2 = -1;
      let entry;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entry = attachers[index2];
          break;
        }
      }
      if (entry) {
        if (isPlainObject(entry[1]) && isPlainObject(value2)) {
          value2 = (0, import_extend.default)(true, entry[1], value2);
        }
        entry[1] = value2;
      } else {
        attachers.push([...arguments]);
      }
    }
  }
  function parse(doc) {
    processor.freeze();
    const file = vfile(doc);
    const Parser2 = processor.Parser;
    assertParser("parse", Parser2);
    if (newable(Parser2, "parse")) {
      return new Parser2(String(file), file).parse();
    }
    return Parser2(String(file), file);
  }
  function stringify(node, doc) {
    processor.freeze();
    const file = vfile(doc);
    const Compiler2 = processor.Compiler;
    assertCompiler("stringify", Compiler2);
    assertNode(node);
    if (newable(Compiler2, "compile")) {
      return new Compiler2(node, file).compile();
    }
    return Compiler2(node, file);
  }
  function run(node, doc, callback) {
    assertNode(node);
    processor.freeze();
    if (!callback && typeof doc === "function") {
      callback = doc;
      doc = void 0;
    }
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      transformers.run(node, vfile(doc), done);
      function done(error, tree, file) {
        tree = tree || node;
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(tree);
        } else {
          callback(null, tree, file);
        }
      }
    }
  }
  function runSync(node, file) {
    let result;
    let complete;
    processor.run(node, file, done);
    assertDone("runSync", "run", complete);
    return result;
    function done(error, tree) {
      bail(error);
      result = tree;
      complete = true;
    }
  }
  function process(doc, callback) {
    processor.freeze();
    assertParser("process", processor.Parser);
    assertCompiler("process", processor.Compiler);
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      const file = vfile(doc);
      processor.run(processor.parse(file), file, (error, tree, file2) => {
        if (error || !tree || !file2) {
          done(error);
        } else {
          const result = processor.stringify(tree, file2);
          if (result === void 0 || result === null) {
          } else if (looksLikeAVFileValue(result)) {
            file2.value = result;
          } else {
            file2.result = result;
          }
          done(error, file2);
        }
      });
      function done(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          callback(null, file2);
        }
      }
    }
  }
  function processSync(doc) {
    let complete;
    processor.freeze();
    assertParser("processSync", processor.Parser);
    assertCompiler("processSync", processor.Compiler);
    const file = vfile(doc);
    processor.process(file, done);
    assertDone("processSync", "process", complete);
    return file;
    function done(error) {
      complete = true;
      bail(error);
    }
  }
}
function newable(value, name) {
  return typeof value === "function" && // Prototypes do exist.
  // type-coverage:ignore-next-line
  value.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes’ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  // type-coverage:ignore-next-line
  (keys(value.prototype) || name in value.prototype);
}
function keys(value) {
  let key;
  for (key in value) {
    if (own.call(value, key)) {
      return true;
    }
  }
  return false;
}
function assertParser(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Parser`");
  }
}
function assertCompiler(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Compiler`");
  }
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node) {
  if (!isPlainObject(node) || typeof node.type !== "string") {
    throw new TypeError("Expected node, got `" + node + "`");
  }
}
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAVFileValue(value) {
  return typeof value === "string" || (0, import_is_buffer2.default)(value);
}

// node_modules/unist-util-position/lib/index.js
var pointStart = point2("start");
var pointEnd = point2("end");
function point2(type) {
  return point3;
  function point3(node) {
    const point4 = node && node.position && node.position[type] || {};
    return {
      // @ts-expect-error: in practice, null is allowed.
      line: point4.line || null,
      // @ts-expect-error: in practice, null is allowed.
      column: point4.column || null,
      // @ts-expect-error: in practice, null is allowed.
      offset: point4.offset > -1 ? point4.offset : null
    };
  }
}

// node_modules/unist-util-is/lib/index.js
var convert = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(test) {
    if (test === void 0 || test === null) {
      return ok;
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  return castFactory(all);
  function all(node) {
    let key;
    for (key in check) {
      if (node[key] !== check[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node) {
    return node && node.type === check;
  }
}
function castFactory(check) {
  return assertion;
  function assertion(node, ...parameters) {
    return Boolean(
      node && typeof node === "object" && "type" in node && // @ts-expect-error: fine.
      Boolean(check.call(this, node, ...parameters))
    );
  }
}
function ok() {
  return true;
}

// node_modules/unist-util-visit-parents/lib/color.browser.js
function color(d) {
  return d;
}

// node_modules/unist-util-visit-parents/lib/index.js
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
var visitParents = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    const is2 = convert(test);
    const step = reverse ? -1 : 1;
    factory(tree, void 0, [])();
    function factory(node, index2, parents) {
      const value = node && typeof node === "object" ? node : {};
      if (typeof value.type === "string") {
        const name = (
          // `hast`
          typeof value.tagName === "string" ? value.tagName : (
            // `xast`
            typeof value.name === "string" ? value.name : void 0
          )
        );
        Object.defineProperty(visit2, "name", {
          value: "node (" + color(node.type + (name ? "<" + name + ">" : "")) + ")"
        });
      }
      return visit2;
      function visit2() {
        let result = [];
        let subresult;
        let offset;
        let grandparents;
        if (!test || is2(node, index2, parents[parents.length - 1] || null)) {
          result = toResult(visitor(node, parents));
          if (result[0] === EXIT) {
            return result;
          }
        }
        if (node.children && result[0] !== SKIP) {
          offset = (reverse ? node.children.length : -1) + step;
          grandparents = parents.concat(node);
          while (offset > -1 && offset < node.children.length) {
            subresult = factory(node.children[offset], offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
        return result;
      }
    }
  }
);
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return [value];
}

// node_modules/unist-util-visit/lib/index.js
var visit = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    visitParents(tree, test, overload, reverse);
    function overload(node, parents) {
      const parent = parents[parents.length - 1];
      return visitor(
        node,
        parent ? parent.children.indexOf(node) : null,
        parent
      );
    }
  }
);

// node_modules/nlcst-to-string/lib/index.js
function toString(value, separator) {
  let index2 = -1;
  if (!value || !Array.isArray(value) && !value.type) {
    throw new Error("Expected node, not `" + value + "`");
  }
  if (typeof value.value === "string")
    return value.value;
  const children = (Array.isArray(value) ? value : value.children) || [];
  if (children.length === 1 && "value" in children[0]) {
    return children[0].value;
  }
  const values = [];
  while (++index2 < children.length) {
    values[index2] = toString(children[index2], separator);
  }
  return values.join(separator || "");
}

// node_modules/nlcst-normalize/lib/index.js
function normalize2(value, options) {
  let result = (typeof value === "string" ? value : toString(value)).toLowerCase().replace(/’/g, "'");
  if (!options || !options.allowDashes) {
    result = result.replace(/-/g, "");
  }
  if (!options || !options.allowApostrophes) {
    result = result.replace(/'/g, "");
  }
  return result;
}

// node_modules/nlcst-is-literal/lib/index.js
var single = [
  "-",
  // Hyphen-minus
  "\u2013",
  // En dash
  "\u2014",
  // Em dash
  ":",
  // Colon
  ";"
  // Semi-colon
];
var pairs = {
  ",": [","],
  "-": ["-"],
  "\u2013": ["\u2013"],
  "\u2014": ["\u2014"],
  '"': ['"'],
  "'": ["'"],
  "\u2018": ["\u2019"],
  "\u201A": ["\u2019"],
  "\u2019": ["\u2019", "\u201A"],
  "\u201C": ["\u201D"],
  "\u201D": ["\u201D"],
  "\u201E": ["\u201D", "\u201C"],
  "\xAB": ["\xBB"],
  "\xBB": ["\xAB"],
  "\u2039": ["\u203A"],
  "\u203A": ["\u2039"],
  "(": [")"],
  "[": ["]"],
  "{": ["}"],
  "\u27E8": ["\u27E9"],
  "\u300C": ["\u300D"]
};
var open = Object.keys(pairs);
function isLiteral(parent, index2) {
  if (!(parent && parent.children)) {
    throw new Error("Parent must be a node");
  }
  if (index2 !== null && typeof index2 === "object" && "type" in index2) {
    index2 = parent.children.indexOf(index2);
    if (index2 === -1) {
      throw new Error("Node must be a child of `parent`");
    }
  }
  if (typeof index2 !== "number" || Number.isNaN(index2)) {
    throw new TypeError("Index must be a number");
  }
  return Boolean(
    !containsWord(parent, -1, index2) && siblingDelimiter(parent, index2, 1, single) || !containsWord(parent, index2, parent.children.length) && siblingDelimiter(parent, index2, -1, single) || isWrapped(parent, index2)
  );
}
function isWrapped(parent, position3) {
  const previous = siblingDelimiter(parent, position3, -1, open);
  if (previous) {
    return siblingDelimiter(parent, position3, 1, pairs[toString(previous)]) !== void 0;
  }
  return false;
}
function siblingDelimiter(parent, position3, step, delimiters) {
  let index2 = position3 + step;
  while (index2 > -1 && index2 < parent.children.length) {
    const sibling = parent.children[index2];
    if (sibling.type === "WordNode" || sibling.type === "SourceNode") {
      break;
    }
    if (sibling.type !== "WhiteSpaceNode") {
      return delimiters.includes(toString(sibling)) ? sibling : void 0;
    }
    index2 += step;
  }
}
function containsWord(parent, start, end) {
  while (++start < end) {
    if (parent.children[start].type === "WordNode") {
      return true;
    }
  }
  return false;
}

// node_modules/nlcst-search/lib/index.js
var own2 = {}.hasOwnProperty;
function search(tree, phrases, handler, options) {
  const config = typeof options === "boolean" ? { allowApostrophes: options } : options || {};
  if (!tree || !tree.type) {
    throw new Error("Expected node");
  }
  if (typeof phrases !== "object") {
    throw new TypeError("Expected object for phrases");
  }
  const byWord = { "*": [] };
  if (Array.isArray(phrases)) {
    let index2 = -1;
    while (++index2 < phrases.length) {
      handlePhrase(phrases[index2]);
    }
  } else {
    let key;
    for (key in phrases) {
      if (own2.call(phrases, key)) {
        handlePhrase(key);
      }
    }
  }
  visit(tree, "WordNode", (node, position3, parent) => {
    if (!parent || position3 === null || !config.allowLiterals && isLiteral(parent, position3)) {
      return;
    }
    const word2 = normalize2(node, config);
    const phrases2 = own2.call(byWord, word2) ? [...byWord["*"], ...byWord[word2]] : byWord["*"];
    let index2 = -1;
    while (++index2 < phrases2.length) {
      const result = test(phrases2[index2], position3, parent);
      if (result) {
        handler(result, position3, parent, phrases2[index2]);
      }
    }
  });
  function test(phrase, position3, parent) {
    const siblings = parent.children;
    const start = position3;
    const expressions = phrase.split(" ").slice(1);
    let index2 = -1;
    position3++;
    while (++index2 < expressions.length) {
      while (position3 < siblings.length) {
        if (siblings[position3].type !== "WhiteSpaceNode")
          break;
        position3++;
      }
      if (!siblings[position3] || siblings[position3].type !== "WordNode" || expressions[index2] !== "*" && normalize2(expressions[index2], config) !== normalize2(siblings[position3], config)) {
        return;
      }
      position3++;
    }
    return siblings.slice(start, position3);
  }
  function handlePhrase(phrase) {
    const firstWord = normalize2(phrase.split(" ", 1)[0], config);
    if (own2.call(byWord, firstWord)) {
      byWord[firstWord].push(phrase);
    } else {
      byWord[firstWord] = [phrase];
    }
  }
}

// node_modules/quotation/index.js
var quotation = (
  /**
   * @type {{
   *   (value: string, open?: string, close?: string): string
   *   (value: string[], open?: string, close?: string): string[]
   * }}
   */
  /**
   * @param {string|Array<string>} value
   * @param {string} open
   * @param {string} close
   * @returns {string|string[]}
   */
  function(value, open2, close) {
    const start = open2 || '"';
    const end = close || start;
    const result = [];
    let index2 = -1;
    if (Array.isArray(value)) {
      while (++index2 < value.length) {
        result[index2] = start + value[index2] + end;
      }
      return result;
    }
    if (typeof value === "string") {
      return start + value + end;
    }
    throw new TypeError("Expected string or array of strings");
  }
);

// node_modules/fillers/index.js
var fillers = [
  "absolutely",
  "actual",
  "actually",
  "amazing",
  "anyway",
  "apparently",
  "approximately",
  "badly",
  "basically",
  "begin",
  "certainly",
  "clearly",
  "completely",
  "definitely",
  "easily",
  "effectively",
  "entirely",
  "especially",
  "essentially",
  "exactly",
  "extremely",
  "fairly",
  "frankly",
  "frequently",
  "fully",
  "generally",
  "hardly",
  "heavily",
  "highly",
  "hopefully",
  "just",
  "largely",
  "like",
  "literally",
  "maybe",
  "might",
  "most",
  "mostly",
  "much",
  "necessarily",
  "nicely",
  "obviously",
  "ok",
  "okay",
  "particularly",
  "perhaps",
  "possibly",
  "practically",
  "precisely",
  "primarily",
  "probably",
  "quite",
  "rather",
  "real",
  "really",
  "relatively",
  "right",
  "seriously",
  "significantly",
  "simply",
  "slightly",
  "so",
  "specifically",
  "start",
  "strongly",
  "stuff",
  "surely",
  "things",
  "too",
  "totally",
  "truly",
  "try",
  "typically",
  "ultimately",
  "usually",
  "very",
  "virtually",
  "well",
  "whatever",
  "whenever",
  "wherever",
  "whoever",
  "widely"
];

// node_modules/hedges/index.js
var hedges = [
  "a bit",
  "about",
  "actually",
  "allege",
  "alleged",
  "almost",
  "almost never",
  "always",
  "and all that",
  "and so forth",
  "apparent",
  "apparently",
  "appear",
  "appear to be",
  "appeared",
  "appears",
  "approximately",
  "around",
  "assume",
  "assumed",
  "assumes",
  "assumption",
  "at least",
  "basically",
  "be sure",
  "believe",
  "believed",
  "believes",
  "bunch",
  "can",
  "certain",
  "certainly",
  "clear",
  "clearly",
  "conceivably",
  "consider",
  "considered",
  "considers",
  "consistent with",
  "could",
  "couple",
  "definite",
  "definitely",
  "diagnostic",
  "don't know",
  "doubt",
  "doubtful",
  "effectively",
  "estimate",
  "estimated",
  "estimates",
  "et cetera",
  "evidently",
  "fairly",
  "few",
  "find",
  "finds",
  "found",
  "frequently",
  "generally",
  "guess",
  "guessed",
  "guesses",
  "hopefully",
  "if i'm understanding you correctly",
  "improbable",
  "in general",
  "in my mind",
  "in my opinion",
  "in my understanding",
  "in my view",
  "inconclusive",
  "indicate",
  "kind of",
  "largely",
  "like",
  "likely",
  "little",
  "look like",
  "looks like",
  "mainly",
  "many",
  "may",
  "maybe",
  "might",
  "more or less",
  "most",
  "mostly",
  "much",
  "must",
  "my impression",
  "my thinking is",
  "my understanding is",
  "necessarily",
  "occasionally",
  "often",
  "overall",
  "partially",
  "perhaps",
  "possibility",
  "possible",
  "possibly",
  "practically",
  "presumable",
  "presumably",
  "pretty",
  "probability",
  "probable",
  "probably",
  "quite",
  "quite clearly",
  "rare",
  "rarely",
  "rather",
  "read",
  "really",
  "roughly",
  "say",
  "says",
  "seem",
  "seemed",
  "seems",
  "seldom",
  "several",
  "should",
  "so far",
  "some",
  "somebody",
  "somehow",
  "someone",
  "something",
  "something or other",
  "sometimes",
  "somewhat",
  "somewhere",
  "sort of",
  "speculate",
  "speculated",
  "speculates",
  "suggest",
  "suggested",
  "suggestive",
  "suggests",
  "suppose",
  "supposed",
  "supposedly",
  "supposes",
  "surely",
  "tend",
  "their impression",
  "think",
  "thinks",
  "thought",
  "understand",
  "understands",
  "understood",
  "unlikely",
  "unsure",
  "usually",
  "virtually",
  "will",
  "would"
];

// node_modules/weasels/index.js
var weasels = [
  "a lot",
  "about",
  "acts",
  "again",
  "all",
  "almost",
  "already",
  "also",
  "anyway",
  "appeared",
  "appears",
  "are a number",
  "arguably",
  "back",
  "be able to",
  "began",
  "believed",
  "better",
  "bit",
  "clearly",
  "close",
  "combats",
  "completely",
  "considered",
  "could",
  "decided",
  "down",
  "effective",
  "efficient",
  "enough",
  "even",
  "ever",
  "exceedingly",
  "excellent",
  "expert",
  "experts",
  "extremely",
  "fairly",
  "far",
  "felt",
  "few",
  "gains",
  "heard",
  "helps",
  "huge",
  "improved",
  "interestingly",
  "is a number",
  "is like",
  "just",
  "knew",
  "largely",
  "like",
  "linked to",
  "literally",
  "looked",
  "looks",
  "lots",
  "many",
  "might",
  "most",
  "mostly",
  "not rocket science",
  "noticed",
  "often",
  "only",
  "outside the box",
  "over",
  "own",
  "pretty",
  "probably",
  "quite",
  "rather",
  "real",
  "realised",
  "realized",
  "really",
  "recognised",
  "recognized",
  "relatively",
  "remarkably",
  "reportedly",
  "saw",
  "seemed",
  "seems",
  "several",
  "significantly",
  "smelled",
  "so",
  "some",
  "somehow",
  "sort",
  "started",
  "still",
  "substantially",
  "supports",
  "supposed",
  "surprisingly",
  "that",
  "then",
  "thought",
  "tiny",
  "touched",
  "understood",
  "up",
  "useful",
  "various",
  "vast",
  "very",
  "virtually",
  "wanted",
  "watched",
  "well",
  "wished",
  "wondered",
  "works"
];

// node_modules/retext-intensify/index.js
var list = [.../* @__PURE__ */ new Set([...fillers, ...hedges, ...weasels])].sort();
var source = "retext-intensify";
var url = "https://github.com/retextjs/retext-intensify#readme";
function retextIntensify(options = {}) {
  const ignore = options.ignore || [];
  const phrases = ignore.length > 0 ? list.filter((d) => !ignore.includes(d)) : list;
  return (tree, file) => {
    search(tree, phrases, (match, _, _1, phrase) => {
      const actual = toString(match);
      let type = "weasel";
      if (!weasels.includes(phrase)) {
        type = fillers.includes(phrase) ? "filler" : "hedge";
      }
      Object.assign(
        file.message(
          "Don\u2019t use " + quotation(actual, "`") + ", " + (type === "weasel" ? "it\u2019s vague or ambiguous" : type === "filler" ? "it doesn\u2019t add meaning" : "it lessens impact"),
          { start: pointStart(match[0]), end: pointEnd(match[match.length - 1]) },
          [source, type].join(":")
        ),
        { actual, expected: [], url }
      );
    });
  };
}

// node_modules/automated-readability/index.js
var characterWeight = 4.71;
var sentenceWeight = 0.5;
var base2 = 21.43;
function automatedReadability(counts) {
  if (!counts || !counts.sentence || !counts.word || !counts.character) {
    return Number.NaN;
  }
  return characterWeight * (counts.character / counts.word) + sentenceWeight * (counts.word / counts.sentence) - base2;
}

// node_modules/coleman-liau/index.js
var letterWeight = 0.0588;
var sentenceWeight2 = 0.296;
var base3 = 15.8;
var percentage = 100;
function colemanLiau(counts) {
  if (!counts || !counts.sentence || !counts.word || !counts.letter) {
    return Number.NaN;
  }
  return letterWeight * (counts.letter / counts.word * percentage) - sentenceWeight2 * (counts.sentence / counts.word * percentage) - base3;
}

// node_modules/dale-chall/index.js
var daleChall = [
  "a",
  "able",
  "aboard",
  "about",
  "above",
  "absent",
  "accept",
  "accident",
  "account",
  "ache",
  "aching",
  "acorn",
  "acre",
  "across",
  "act",
  "acts",
  "add",
  "address",
  "admire",
  "adventure",
  "afar",
  "afraid",
  "after",
  "afternoon",
  "afterward",
  "afterwards",
  "again",
  "against",
  "age",
  "aged",
  "ago",
  "agree",
  "ah",
  "ahead",
  "aid",
  "aim",
  "air",
  "airfield",
  "airplane",
  "airport",
  "airship",
  "airy",
  "alarm",
  "alike",
  "alive",
  "all",
  "alley",
  "alligator",
  "allow",
  "almost",
  "alone",
  "along",
  "aloud",
  "already",
  "also",
  "always",
  "am",
  "america",
  "american",
  "among",
  "amount",
  "an",
  "and",
  "angel",
  "anger",
  "angry",
  "animal",
  "another",
  "answer",
  "ant",
  "any",
  "anybody",
  "anyhow",
  "anyone",
  "anything",
  "anyway",
  "anywhere",
  "apart",
  "apartment",
  "ape",
  "apiece",
  "appear",
  "apple",
  "april",
  "apron",
  "are",
  "aren't",
  "arise",
  "arithmetic",
  "arm",
  "armful",
  "army",
  "arose",
  "around",
  "arrange",
  "arrive",
  "arrived",
  "arrow",
  "art",
  "artist",
  "as",
  "ash",
  "ashes",
  "aside",
  "ask",
  "asleep",
  "at",
  "ate",
  "attack",
  "attend",
  "attention",
  "august",
  "aunt",
  "author",
  "auto",
  "automobile",
  "autumn",
  "avenue",
  "awake",
  "awaken",
  "away",
  "awful",
  "awfully",
  "awhile",
  "ax",
  "axe",
  "baa",
  "babe",
  "babies",
  "back",
  "background",
  "backward",
  "backwards",
  "bacon",
  "bad",
  "badge",
  "badly",
  "bag",
  "bake",
  "baker",
  "bakery",
  "baking",
  "ball",
  "balloon",
  "banana",
  "band",
  "bandage",
  "bang",
  "banjo",
  "bank",
  "banker",
  "bar",
  "barber",
  "bare",
  "barefoot",
  "barely",
  "bark",
  "barn",
  "barrel",
  "base",
  "baseball",
  "basement",
  "basket",
  "bat",
  "batch",
  "bath",
  "bathe",
  "bathing",
  "bathroom",
  "bathtub",
  "battle",
  "battleship",
  "bay",
  "be",
  "beach",
  "bead",
  "beam",
  "bean",
  "bear",
  "beard",
  "beast",
  "beat",
  "beating",
  "beautiful",
  "beautify",
  "beauty",
  "became",
  "because",
  "become",
  "becoming",
  "bed",
  "bedbug",
  "bedroom",
  "bedspread",
  "bedtime",
  "bee",
  "beech",
  "beef",
  "beefsteak",
  "beehive",
  "been",
  "beer",
  "beet",
  "before",
  "beg",
  "began",
  "beggar",
  "begged",
  "begin",
  "beginning",
  "begun",
  "behave",
  "behind",
  "being",
  "believe",
  "bell",
  "belong",
  "below",
  "belt",
  "bench",
  "bend",
  "beneath",
  "bent",
  "berries",
  "berry",
  "beside",
  "besides",
  "best",
  "bet",
  "better",
  "between",
  "bib",
  "bible",
  "bicycle",
  "bid",
  "big",
  "bigger",
  "bill",
  "billboard",
  "bin",
  "bind",
  "bird",
  "birth",
  "birthday",
  "biscuit",
  "bit",
  "bite",
  "biting",
  "bitter",
  "black",
  "blackberry",
  "blackbird",
  "blackboard",
  "blackness",
  "blacksmith",
  "blame",
  "blank",
  "blanket",
  "blast",
  "blaze",
  "bleed",
  "bless",
  "blessing",
  "blew",
  "blind",
  "blindfold",
  "blinds",
  "block",
  "blood",
  "bloom",
  "blossom",
  "blot",
  "blow",
  "blue",
  "blueberry",
  "bluebird",
  "blush",
  "board",
  "boast",
  "boat",
  "bob",
  "bobwhite",
  "bodies",
  "body",
  "boil",
  "boiler",
  "bold",
  "bone",
  "bonnet",
  "boo",
  "book",
  "bookcase",
  "bookkeeper",
  "boom",
  "boot",
  "born",
  "borrow",
  "boss",
  "both",
  "bother",
  "bottle",
  "bottom",
  "bought",
  "bounce",
  "bow",
  "bow-wow",
  "bowl",
  "box",
  "boxcar",
  "boxer",
  "boxes",
  "boy",
  "boyhood",
  "bracelet",
  "brain",
  "brake",
  "bran",
  "branch",
  "brass",
  "brave",
  "bread",
  "break",
  "breakfast",
  "breast",
  "breath",
  "breathe",
  "breeze",
  "brick",
  "bride",
  "bridge",
  "bright",
  "brightness",
  "bring",
  "broad",
  "broadcast",
  "broke",
  "broken",
  "brook",
  "broom",
  "brother",
  "brought",
  "brown",
  "brush",
  "bubble",
  "bucket",
  "buckle",
  "bud",
  "buffalo",
  "bug",
  "buggy",
  "build",
  "building",
  "built",
  "bulb",
  "bull",
  "bullet",
  "bum",
  "bumblebee",
  "bump",
  "bun",
  "bunch",
  "bundle",
  "bunny",
  "burn",
  "burst",
  "bury",
  "bus",
  "bush",
  "bushel",
  "business",
  "busy",
  "but",
  "butcher",
  "butt",
  "butter",
  "buttercup",
  "butterfly",
  "buttermilk",
  "butterscotch",
  "button",
  "buttonhole",
  "buy",
  "buzz",
  "by",
  "bye",
  "cab",
  "cabbage",
  "cabin",
  "cabinet",
  "cackle",
  "cage",
  "cake",
  "calendar",
  "calf",
  "call",
  "caller",
  "calling",
  "came",
  "camel",
  "camp",
  "campfire",
  "can",
  "can't",
  "canal",
  "canary",
  "candle",
  "candlestick",
  "candy",
  "cane",
  "cannon",
  "cannot",
  "canoe",
  "canyon",
  "cap",
  "cape",
  "capital",
  "captain",
  "car",
  "card",
  "cardboard",
  "care",
  "careful",
  "careless",
  "carelessness",
  "carload",
  "carpenter",
  "carpet",
  "carriage",
  "carrot",
  "carry",
  "cart",
  "carve",
  "case",
  "cash",
  "cashier",
  "castle",
  "cat",
  "catbird",
  "catch",
  "catcher",
  "caterpillar",
  "catfish",
  "catsup",
  "cattle",
  "caught",
  "cause",
  "cave",
  "ceiling",
  "cell",
  "cellar",
  "cent",
  "center",
  "cereal",
  "certain",
  "certainly",
  "chain",
  "chair",
  "chalk",
  "champion",
  "chance",
  "change",
  "chap",
  "charge",
  "charm",
  "chart",
  "chase",
  "chatter",
  "cheap",
  "cheat",
  "check",
  "checkers",
  "cheek",
  "cheer",
  "cheese",
  "cherry",
  "chest",
  "chew",
  "chick",
  "chicken",
  "chief",
  "child",
  "childhood",
  "children",
  "chill",
  "chilly",
  "chimney",
  "chin",
  "china",
  "chip",
  "chipmunk",
  "chocolate",
  "choice",
  "choose",
  "chop",
  "chorus",
  "chose",
  "chosen",
  "christen",
  "christmas",
  "church",
  "churn",
  "cigarette",
  "circle",
  "circus",
  "citizen",
  "city",
  "clang",
  "clap",
  "class",
  "classmate",
  "classroom",
  "claw",
  "clay",
  "clean",
  "cleaner",
  "clear",
  "clerk",
  "clever",
  "click",
  "cliff",
  "climb",
  "clip",
  "cloak",
  "clock",
  "close",
  "closet",
  "cloth",
  "clothes",
  "clothing",
  "cloud",
  "cloudy",
  "clover",
  "clown",
  "club",
  "cluck",
  "clump",
  "coach",
  "coal",
  "coast",
  "coat",
  "cob",
  "cobbler",
  "cocoa",
  "coconut",
  "cocoon",
  "cod",
  "codfish",
  "coffee",
  "coffeepot",
  "coin",
  "cold",
  "collar",
  "college",
  "color",
  "colored",
  "colt",
  "column",
  "comb",
  "come",
  "comfort",
  "comic",
  "coming",
  "company",
  "compare",
  "conductor",
  "cone",
  "connect",
  "coo",
  "cook",
  "cooked",
  "cookie",
  "cookies",
  "cooking",
  "cool",
  "cooler",
  "coop",
  "copper",
  "copy",
  "cord",
  "cork",
  "corn",
  "corner",
  "correct",
  "cost",
  "cot",
  "cottage",
  "cotton",
  "couch",
  "cough",
  "could",
  "couldn't",
  "count",
  "counter",
  "country",
  "county",
  "course",
  "court",
  "cousin",
  "cover",
  "cow",
  "coward",
  "cowardly",
  "cowboy",
  "cozy",
  "crab",
  "crack",
  "cracker",
  "cradle",
  "cramps",
  "cranberry",
  "crank",
  "cranky",
  "crash",
  "crawl",
  "crazy",
  "cream",
  "creamy",
  "creek",
  "creep",
  "crept",
  "cried",
  "cries",
  "croak",
  "crook",
  "crooked",
  "crop",
  "cross",
  "cross-eyed",
  "crossing",
  "crow",
  "crowd",
  "crowded",
  "crown",
  "cruel",
  "crumb",
  "crumble",
  "crush",
  "crust",
  "cry",
  "cub",
  "cuff",
  "cup",
  "cupboard",
  "cupful",
  "cure",
  "curl",
  "curly",
  "curtain",
  "curve",
  "cushion",
  "custard",
  "customer",
  "cut",
  "cute",
  "cutting",
  "dab",
  "dad",
  "daddy",
  "daily",
  "dairy",
  "daisy",
  "dam",
  "damage",
  "dame",
  "damp",
  "dance",
  "dancer",
  "dancing",
  "dandy",
  "danger",
  "dangerous",
  "dare",
  "dark",
  "darkness",
  "darling",
  "darn",
  "dart",
  "dash",
  "date",
  "daughter",
  "dawn",
  "day",
  "daybreak",
  "daytime",
  "dead",
  "deaf",
  "deal",
  "dear",
  "death",
  "december",
  "decide",
  "deck",
  "deed",
  "deep",
  "deer",
  "defeat",
  "defend",
  "defense",
  "delight",
  "den",
  "dentist",
  "depend",
  "deposit",
  "describe",
  "desert",
  "deserve",
  "desire",
  "desk",
  "destroy",
  "devil",
  "dew",
  "diamond",
  "did",
  "didn't",
  "die",
  "died",
  "dies",
  "difference",
  "different",
  "dig",
  "dim",
  "dime",
  "dine",
  "ding-dong",
  "dinner",
  "dip",
  "direct",
  "direction",
  "dirt",
  "dirty",
  "discover",
  "dish",
  "dislike",
  "dismiss",
  "ditch",
  "dive",
  "diver",
  "divide",
  "do",
  "dock",
  "doctor",
  "does",
  "doesn't",
  "dog",
  "doll",
  "dollar",
  "dolly",
  "don't",
  "done",
  "donkey",
  "door",
  "doorbell",
  "doorknob",
  "doorstep",
  "dope",
  "dot",
  "double",
  "dough",
  "dove",
  "down",
  "downstairs",
  "downtown",
  "dozen",
  "drag",
  "drain",
  "drank",
  "draw",
  "drawer",
  "drawing",
  "dream",
  "dress",
  "dresser",
  "dressmaker",
  "drew",
  "dried",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "driven",
  "driver",
  "drop",
  "drove",
  "drown",
  "drowsy",
  "drub",
  "drum",
  "drunk",
  "dry",
  "duck",
  "due",
  "dug",
  "dull",
  "dumb",
  "dump",
  "during",
  "dust",
  "dusty",
  "duty",
  "dwarf",
  "dwell",
  "dwelt",
  "dying",
  "each",
  "eager",
  "eagle",
  "ear",
  "early",
  "earn",
  "earth",
  "east",
  "eastern",
  "easy",
  "eat",
  "eaten",
  "edge",
  "egg",
  "eh",
  "eight",
  "eighteen",
  "eighth",
  "eighty",
  "either",
  "elbow",
  "elder",
  "eldest",
  "electric",
  "electricity",
  "elephant",
  "eleven",
  "elf",
  "elm",
  "else",
  "elsewhere",
  "empty",
  "end",
  "ending",
  "enemy",
  "engine",
  "engineer",
  "english",
  "enjoy",
  "enough",
  "enter",
  "envelope",
  "equal",
  "erase",
  "eraser",
  "errand",
  "escape",
  "eve",
  "even",
  "evening",
  "ever",
  "every",
  "everybody",
  "everyday",
  "everyone",
  "everything",
  "everywhere",
  "evil",
  "exact",
  "except",
  "exchange",
  "excited",
  "exciting",
  "excuse",
  "exit",
  "expect",
  "explain",
  "extra",
  "eye",
  "eyebrow",
  "fable",
  "face",
  "facing",
  "fact",
  "factory",
  "fail",
  "faint",
  "fair",
  "fairy",
  "faith",
  "fake",
  "fall",
  "false",
  "family",
  "fan",
  "fancy",
  "far",
  "far-off",
  "faraway",
  "fare",
  "farm",
  "farmer",
  "farming",
  "farther",
  "fashion",
  "fast",
  "fasten",
  "fat",
  "father",
  "fault",
  "favor",
  "favorite",
  "fear",
  "feast",
  "feather",
  "february",
  "fed",
  "feed",
  "feel",
  "feet",
  "fell",
  "fellow",
  "felt",
  "fence",
  "fever",
  "few",
  "fib",
  "fiddle",
  "field",
  "fife",
  "fifteen",
  "fifth",
  "fifty",
  "fig",
  "fight",
  "figure",
  "file",
  "fill",
  "film",
  "finally",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firearm",
  "firecracker",
  "fireplace",
  "fireworks",
  "firing",
  "first",
  "fish",
  "fisherman",
  "fist",
  "fit",
  "fits",
  "five",
  "fix",
  "flag",
  "flake",
  "flame",
  "flap",
  "flash",
  "flashlight",
  "flat",
  "flea",
  "flesh",
  "flew",
  "flies",
  "flight",
  "flip",
  "flip-flop",
  "float",
  "flock",
  "flood",
  "floor",
  "flop",
  "flour",
  "flow",
  "flower",
  "flowery",
  "flutter",
  "fly",
  "foam",
  "fog",
  "foggy",
  "fold",
  "folks",
  "follow",
  "following",
  "fond",
  "food",
  "fool",
  "foolish",
  "foot",
  "football",
  "footprint",
  "for",
  "forehead",
  "forest",
  "forget",
  "forgive",
  "forgot",
  "forgotten",
  "fork",
  "form",
  "fort",
  "forth",
  "fortune",
  "forty",
  "forward",
  "fought",
  "found",
  "fountain",
  "four",
  "fourteen",
  "fourth",
  "fox",
  "frame",
  "free",
  "freedom",
  "freeze",
  "freight",
  "french",
  "fresh",
  "fret",
  "friday",
  "fried",
  "friend",
  "friendly",
  "friendship",
  "frighten",
  "frog",
  "from",
  "front",
  "frost",
  "frown",
  "froze",
  "fruit",
  "fry",
  "fudge",
  "fuel",
  "full",
  "fully",
  "fun",
  "funny",
  "fur",
  "furniture",
  "further",
  "fuzzy",
  "gain",
  "gallon",
  "gallop",
  "game",
  "gang",
  "garage",
  "garbage",
  "garden",
  "gas",
  "gasoline",
  "gate",
  "gather",
  "gave",
  "gay",
  "gear",
  "geese",
  "general",
  "gentle",
  "gentleman",
  "gentlemen",
  "geography",
  "get",
  "getting",
  "giant",
  "gift",
  "gingerbread",
  "girl",
  "give",
  "given",
  "giving",
  "glad",
  "gladly",
  "glance",
  "glass",
  "glasses",
  "gleam",
  "glide",
  "glory",
  "glove",
  "glow",
  "glue",
  "go",
  "goal",
  "goat",
  "gobble",
  "god",
  "godmother",
  "goes",
  "going",
  "gold",
  "golden",
  "goldfish",
  "golf",
  "gone",
  "good",
  "good-by",
  "good-bye",
  "good-looking",
  "goodbye",
  "goodness",
  "goods",
  "goody",
  "goose",
  "gooseberry",
  "got",
  "govern",
  "government",
  "gown",
  "grab",
  "gracious",
  "grade",
  "grain",
  "grand",
  "grandchild",
  "grandchildren",
  "granddaughter",
  "grandfather",
  "grandma",
  "grandmother",
  "grandpa",
  "grandson",
  "grandstand",
  "grape",
  "grapefruit",
  "grapes",
  "grass",
  "grasshopper",
  "grateful",
  "grave",
  "gravel",
  "graveyard",
  "gravy",
  "gray",
  "graze",
  "grease",
  "great",
  "green",
  "greet",
  "grew",
  "grind",
  "groan",
  "grocery",
  "ground",
  "group",
  "grove",
  "grow",
  "guard",
  "guess",
  "guest",
  "guide",
  "gulf",
  "gum",
  "gun",
  "gunpowder",
  "guy",
  "ha",
  "habit",
  "had",
  "hadn't",
  "hail",
  "hair",
  "haircut",
  "hairpin",
  "half",
  "hall",
  "halt",
  "ham",
  "hammer",
  "hand",
  "handful",
  "handkerchief",
  "handle",
  "handwriting",
  "hang",
  "happen",
  "happily",
  "happiness",
  "happy",
  "harbor",
  "hard",
  "hardly",
  "hardship",
  "hardware",
  "hare",
  "hark",
  "harm",
  "harness",
  "harp",
  "harvest",
  "has",
  "hasn't",
  "haste",
  "hasten",
  "hasty",
  "hat",
  "hatch",
  "hatchet",
  "hate",
  "haul",
  "have",
  "haven't",
  "having",
  "hawk",
  "hay",
  "hayfield",
  "haystack",
  "he",
  "he'd",
  "he'll",
  "he's",
  "head",
  "headache",
  "heal",
  "health",
  "healthy",
  "heap",
  "hear",
  "heard",
  "hearing",
  "heart",
  "heat",
  "heater",
  "heaven",
  "heavy",
  "heel",
  "height",
  "held",
  "hell",
  "hello",
  "helmet",
  "help",
  "helper",
  "helpful",
  "hem",
  "hen",
  "henhouse",
  "her",
  "herd",
  "here",
  "here's",
  "hero",
  "hers",
  "herself",
  "hey",
  "hickory",
  "hid",
  "hidden",
  "hide",
  "high",
  "highway",
  "hill",
  "hillside",
  "hilltop",
  "hilly",
  "him",
  "himself",
  "hind",
  "hint",
  "hip",
  "hire",
  "his",
  "hiss",
  "history",
  "hit",
  "hitch",
  "hive",
  "ho",
  "hoe",
  "hog",
  "hold",
  "holder",
  "hole",
  "holiday",
  "hollow",
  "holy",
  "home",
  "homely",
  "homesick",
  "honest",
  "honey",
  "honeybee",
  "honeymoon",
  "honk",
  "honor",
  "hood",
  "hoof",
  "hook",
  "hoop",
  "hop",
  "hope",
  "hopeful",
  "hopeless",
  "horn",
  "horse",
  "horseback",
  "horseshoe",
  "hose",
  "hospital",
  "host",
  "hot",
  "hotel",
  "hound",
  "hour",
  "house",
  "housetop",
  "housewife",
  "housework",
  "how",
  "however",
  "howl",
  "hug",
  "huge",
  "hum",
  "humble",
  "hump",
  "hundred",
  "hung",
  "hunger",
  "hungry",
  "hunk",
  "hunt",
  "hunter",
  "hurrah",
  "hurried",
  "hurry",
  "hurt",
  "husband",
  "hush",
  "hut",
  "hymn",
  "i",
  "i'd",
  "i'll",
  "i'm",
  "i've",
  "ice",
  "icy",
  "idea",
  "ideal",
  "if",
  "ill",
  "important",
  "impossible",
  "improve",
  "in",
  "inch",
  "inches",
  "income",
  "indeed",
  "indian",
  "indoors",
  "ink",
  "inn",
  "insect",
  "inside",
  "instant",
  "instead",
  "insult",
  "intend",
  "interested",
  "interesting",
  "into",
  "invite",
  "iron",
  "is",
  "island",
  "isn't",
  "it",
  "it's",
  "its",
  "itself",
  "ivory",
  "ivy",
  "jacket",
  "jacks",
  "jail",
  "jam",
  "january",
  "jar",
  "jaw",
  "jay",
  "jelly",
  "jellyfish",
  "jerk",
  "jig",
  "job",
  "jockey",
  "join",
  "joke",
  "joking",
  "jolly",
  "journey",
  "joy",
  "joyful",
  "joyous",
  "judge",
  "jug",
  "juice",
  "juicy",
  "july",
  "jump",
  "june",
  "junior",
  "junk",
  "just",
  "keen",
  "keep",
  "kept",
  "kettle",
  "key",
  "kick",
  "kid",
  "kill",
  "killed",
  "kind",
  "kindly",
  "kindness",
  "king",
  "kingdom",
  "kiss",
  "kitchen",
  "kite",
  "kitten",
  "kitty",
  "knee",
  "kneel",
  "knew",
  "knife",
  "knit",
  "knives",
  "knob",
  "knock",
  "knot",
  "know",
  "known",
  "lace",
  "lad",
  "ladder",
  "ladies",
  "lady",
  "laid",
  "lake",
  "lamb",
  "lame",
  "lamp",
  "land",
  "lane",
  "language",
  "lantern",
  "lap",
  "lard",
  "large",
  "lash",
  "lass",
  "last",
  "late",
  "laugh",
  "laundry",
  "law",
  "lawn",
  "lawyer",
  "lay",
  "lazy",
  "lead",
  "leader",
  "leaf",
  "leak",
  "lean",
  "leap",
  "learn",
  "learned",
  "least",
  "leather",
  "leave",
  "leaving",
  "led",
  "left",
  "leg",
  "lemon",
  "lemonade",
  "lend",
  "length",
  "less",
  "lesson",
  "let",
  "let's",
  "letter",
  "letting",
  "lettuce",
  "level",
  "liberty",
  "library",
  "lice",
  "lick",
  "lid",
  "lie",
  "life",
  "lift",
  "light",
  "lightness",
  "lightning",
  "like",
  "likely",
  "liking",
  "lily",
  "limb",
  "lime",
  "limp",
  "line",
  "linen",
  "lion",
  "lip",
  "list",
  "listen",
  "lit",
  "little",
  "live",
  "lively",
  "liver",
  "lives",
  "living",
  "lizard",
  "load",
  "loaf",
  "loan",
  "loaves",
  "lock",
  "locomotive",
  "log",
  "lone",
  "lonely",
  "lonesome",
  "long",
  "look",
  "lookout",
  "loop",
  "loose",
  "lord",
  "lose",
  "loser",
  "loss",
  "lost",
  "lot",
  "loud",
  "love",
  "lovely",
  "lover",
  "low",
  "luck",
  "lucky",
  "lumber",
  "lump",
  "lunch",
  "lying",
  "ma",
  "machine",
  "machinery",
  "mad",
  "made",
  "magazine",
  "magic",
  "maid",
  "mail",
  "mailbox",
  "mailman",
  "major",
  "make",
  "making",
  "male",
  "mama",
  "mamma",
  "man",
  "manager",
  "mane",
  "manger",
  "many",
  "map",
  "maple",
  "marble",
  "march",
  "mare",
  "mark",
  "market",
  "marriage",
  "married",
  "marry",
  "mask",
  "mast",
  "master",
  "mat",
  "match",
  "matter",
  "mattress",
  "may",
  "maybe",
  "mayor",
  "maypole",
  "me",
  "meadow",
  "meal",
  "mean",
  "means",
  "meant",
  "measure",
  "meat",
  "medicine",
  "meet",
  "meeting",
  "melt",
  "member",
  "men",
  "mend",
  "meow",
  "merry",
  "mess",
  "message",
  "met",
  "metal",
  "mew",
  "mice",
  "middle",
  "midnight",
  "might",
  "mighty",
  "mile",
  "miler",
  "milk",
  "milkman",
  "mill",
  "million",
  "mind",
  "mine",
  "miner",
  "mint",
  "minute",
  "mirror",
  "mischief",
  "miss",
  "misspell",
  "mistake",
  "misty",
  "mitt",
  "mitten",
  "mix",
  "moment",
  "monday",
  "money",
  "monkey",
  "month",
  "moo",
  "moon",
  "moonlight",
  "moose",
  "mop",
  "more",
  "morning",
  "morrow",
  "moss",
  "most",
  "mostly",
  "mother",
  "motor",
  "mount",
  "mountain",
  "mouse",
  "mouth",
  "move",
  "movie",
  "movies",
  "moving",
  "mow",
  "mr.",
  "mrs.",
  "much",
  "mud",
  "muddy",
  "mug",
  "mule",
  "multiply",
  "murder",
  "music",
  "must",
  "my",
  "myself",
  "nail",
  "name",
  "nap",
  "napkin",
  "narrow",
  "nasty",
  "naughty",
  "navy",
  "near",
  "nearby",
  "nearly",
  "neat",
  "neck",
  "necktie",
  "need",
  "needle",
  "needn't",
  "negro",
  "neighbor",
  "neighborhood",
  "neither",
  "nerve",
  "nest",
  "net",
  "never",
  "nevermore",
  "new",
  "news",
  "newspaper",
  "next",
  "nibble",
  "nice",
  "nickel",
  "night",
  "nightgown",
  "nine",
  "nineteen",
  "ninety",
  "no",
  "nobody",
  "nod",
  "noise",
  "noisy",
  "none",
  "noon",
  "nor",
  "north",
  "northern",
  "nose",
  "not",
  "note",
  "nothing",
  "notice",
  "november",
  "now",
  "nowhere",
  "number",
  "nurse",
  "nut",
  "o'clock",
  "oak",
  "oar",
  "oatmeal",
  "oats",
  "obey",
  "ocean",
  "october",
  "odd",
  "of",
  "off",
  "offer",
  "office",
  "officer",
  "often",
  "oh",
  "oil",
  "old",
  "old-fashioned",
  "on",
  "once",
  "one",
  "onion",
  "only",
  "onward",
  "open",
  "or",
  "orange",
  "orchard",
  "order",
  "ore",
  "organ",
  "other",
  "otherwise",
  "ouch",
  "ought",
  "our",
  "ours",
  "ourselves",
  "out",
  "outdoors",
  "outfit",
  "outlaw",
  "outline",
  "outside",
  "outward",
  "oven",
  "over",
  "overalls",
  "overcoat",
  "overeat",
  "overhead",
  "overhear",
  "overnight",
  "overturn",
  "owe",
  "owing",
  "owl",
  "own",
  "owner",
  "ox",
  "pa",
  "pace",
  "pack",
  "package",
  "pad",
  "page",
  "paid",
  "pail",
  "pain",
  "painful",
  "paint",
  "painter",
  "painting",
  "pair",
  "pal",
  "palace",
  "pale",
  "pan",
  "pancake",
  "pane",
  "pansy",
  "pants",
  "papa",
  "paper",
  "parade",
  "pardon",
  "parent",
  "park",
  "part",
  "partly",
  "partner",
  "party",
  "pass",
  "passenger",
  "past",
  "paste",
  "pasture",
  "pat",
  "patch",
  "path",
  "patter",
  "pave",
  "pavement",
  "paw",
  "pay",
  "payment",
  "pea",
  "peace",
  "peaceful",
  "peach",
  "peaches",
  "peak",
  "peanut",
  "pear",
  "pearl",
  "peas",
  "peck",
  "peek",
  "peel",
  "peep",
  "peg",
  "pen",
  "pencil",
  "penny",
  "people",
  "pepper",
  "peppermint",
  "perfume",
  "perhaps",
  "person",
  "pet",
  "phone",
  "piano",
  "pick",
  "pickle",
  "picnic",
  "picture",
  "pie",
  "piece",
  "pig",
  "pigeon",
  "piggy",
  "pile",
  "pill",
  "pillow",
  "pin",
  "pine",
  "pineapple",
  "pink",
  "pint",
  "pipe",
  "pistol",
  "pit",
  "pitch",
  "pitcher",
  "pity",
  "place",
  "plain",
  "plan",
  "plane",
  "plant",
  "plate",
  "platform",
  "platter",
  "play",
  "player",
  "playground",
  "playhouse",
  "playmate",
  "plaything",
  "pleasant",
  "please",
  "pleasure",
  "plenty",
  "plow",
  "plug",
  "plum",
  "pocket",
  "pocketbook",
  "poem",
  "point",
  "poison",
  "poke",
  "pole",
  "police",
  "policeman",
  "polish",
  "polite",
  "pond",
  "ponies",
  "pony",
  "pool",
  "poor",
  "pop",
  "popcorn",
  "popped",
  "porch",
  "pork",
  "possible",
  "post",
  "postage",
  "postman",
  "pot",
  "potato",
  "potatoes",
  "pound",
  "pour",
  "powder",
  "power",
  "powerful",
  "praise",
  "pray",
  "prayer",
  "prepare",
  "present",
  "pretty",
  "price",
  "prick",
  "prince",
  "princess",
  "print",
  "prison",
  "prize",
  "promise",
  "proper",
  "protect",
  "proud",
  "prove",
  "prune",
  "public",
  "puddle",
  "puff",
  "pull",
  "pump",
  "pumpkin",
  "punch",
  "punish",
  "pup",
  "pupil",
  "puppy",
  "pure",
  "purple",
  "purse",
  "push",
  "puss",
  "pussy",
  "pussycat",
  "put",
  "putting",
  "puzzle",
  "quack",
  "quart",
  "quarter",
  "queen",
  "queer",
  "question",
  "quick",
  "quickly",
  "quiet",
  "quilt",
  "quit",
  "quite",
  "rabbit",
  "race",
  "rack",
  "radio",
  "radish",
  "rag",
  "rail",
  "railroad",
  "railway",
  "rain",
  "rainbow",
  "rainy",
  "raise",
  "raisin",
  "rake",
  "ram",
  "ran",
  "ranch",
  "rang",
  "rap",
  "rapidly",
  "rat",
  "rate",
  "rather",
  "rattle",
  "raw",
  "ray",
  "reach",
  "read",
  "reader",
  "reading",
  "ready",
  "real",
  "really",
  "reap",
  "rear",
  "reason",
  "rebuild",
  "receive",
  "recess",
  "record",
  "red",
  "redbird",
  "redbreast",
  "refuse",
  "reindeer",
  "rejoice",
  "remain",
  "remember",
  "remind",
  "remove",
  "rent",
  "repair",
  "repay",
  "repeat",
  "report",
  "rest",
  "return",
  "review",
  "reward",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "rid",
  "riddle",
  "ride",
  "rider",
  "riding",
  "right",
  "rim",
  "ring",
  "rip",
  "ripe",
  "rise",
  "rising",
  "river",
  "road",
  "roadside",
  "roar",
  "roast",
  "rob",
  "robber",
  "robe",
  "robin",
  "rock",
  "rocket",
  "rocky",
  "rode",
  "roll",
  "roller",
  "roof",
  "room",
  "rooster",
  "root",
  "rope",
  "rose",
  "rosebud",
  "rot",
  "rotten",
  "rough",
  "round",
  "route",
  "row",
  "rowboat",
  "royal",
  "rub",
  "rubbed",
  "rubber",
  "rubbish",
  "rug",
  "rule",
  "ruler",
  "rumble",
  "run",
  "rung",
  "runner",
  "running",
  "rush",
  "rust",
  "rusty",
  "rye",
  "sack",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "safety",
  "said",
  "sail",
  "sailboat",
  "sailor",
  "saint",
  "salad",
  "sale",
  "salt",
  "same",
  "sand",
  "sandwich",
  "sandy",
  "sang",
  "sank",
  "sap",
  "sash",
  "sat",
  "satin",
  "satisfactory",
  "saturday",
  "sausage",
  "savage",
  "save",
  "savings",
  "saw",
  "say",
  "scab",
  "scales",
  "scare",
  "scarf",
  "school",
  "schoolboy",
  "schoolhouse",
  "schoolmaster",
  "schoolroom",
  "scorch",
  "score",
  "scrap",
  "scrape",
  "scratch",
  "scream",
  "screen",
  "screw",
  "scrub",
  "sea",
  "seal",
  "seam",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "see",
  "seed",
  "seeing",
  "seek",
  "seem",
  "seen",
  "seesaw",
  "select",
  "self",
  "selfish",
  "sell",
  "send",
  "sense",
  "sent",
  "sentence",
  "separate",
  "september",
  "servant",
  "serve",
  "service",
  "set",
  "setting",
  "settle",
  "settlement",
  "seven",
  "seventeen",
  "seventh",
  "seventy",
  "several",
  "sew",
  "shade",
  "shadow",
  "shady",
  "shake",
  "shaker",
  "shaking",
  "shall",
  "shame",
  "shan't",
  "shape",
  "share",
  "sharp",
  "shave",
  "she",
  "she'd",
  "she'll",
  "she's",
  "shear",
  "shears",
  "shed",
  "sheep",
  "sheet",
  "shelf",
  "shell",
  "shepherd",
  "shine",
  "shining",
  "shiny",
  "ship",
  "shirt",
  "shock",
  "shoe",
  "shoemaker",
  "shone",
  "shook",
  "shoot",
  "shop",
  "shopping",
  "shore",
  "short",
  "shot",
  "should",
  "shoulder",
  "shouldn't",
  "shout",
  "shovel",
  "show",
  "shower",
  "shut",
  "shy",
  "sick",
  "sickness",
  "side",
  "sidewalk",
  "sideways",
  "sigh",
  "sight",
  "sign",
  "silence",
  "silent",
  "silk",
  "sill",
  "silly",
  "silver",
  "simple",
  "sin",
  "since",
  "sing",
  "singer",
  "single",
  "sink",
  "sip",
  "sir",
  "sis",
  "sissy",
  "sister",
  "sit",
  "sitting",
  "six",
  "sixteen",
  "sixth",
  "sixty",
  "size",
  "skate",
  "skater",
  "ski",
  "skin",
  "skip",
  "skirt",
  "sky",
  "slam",
  "slap",
  "slate",
  "slave",
  "sled",
  "sleep",
  "sleepy",
  "sleeve",
  "sleigh",
  "slept",
  "slice",
  "slid",
  "slide",
  "sling",
  "slip",
  "slipped",
  "slipper",
  "slippery",
  "slit",
  "slow",
  "slowly",
  "sly",
  "smack",
  "small",
  "smart",
  "smell",
  "smile",
  "smoke",
  "smooth",
  "snail",
  "snake",
  "snap",
  "snapping",
  "sneeze",
  "snow",
  "snowball",
  "snowflake",
  "snowy",
  "snuff",
  "snug",
  "so",
  "soak",
  "soap",
  "sob",
  "socks",
  "sod",
  "soda",
  "sofa",
  "soft",
  "soil",
  "sold",
  "soldier",
  "sole",
  "some",
  "somebody",
  "somehow",
  "someone",
  "something",
  "sometime",
  "sometimes",
  "somewhere",
  "son",
  "song",
  "soon",
  "sore",
  "sorrow",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "sour",
  "south",
  "southern",
  "space",
  "spade",
  "spank",
  "sparrow",
  "speak",
  "speaker",
  "spear",
  "speech",
  "speed",
  "spell",
  "spelling",
  "spend",
  "spent",
  "spider",
  "spike",
  "spill",
  "spin",
  "spinach",
  "spirit",
  "spit",
  "splash",
  "spoil",
  "spoke",
  "spook",
  "spoon",
  "sport",
  "spot",
  "spread",
  "spring",
  "springtime",
  "sprinkle",
  "square",
  "squash",
  "squeak",
  "squeeze",
  "squirrel",
  "stable",
  "stack",
  "stage",
  "stair",
  "stall",
  "stamp",
  "stand",
  "star",
  "stare",
  "start",
  "starve",
  "state",
  "states",
  "station",
  "stay",
  "steak",
  "steal",
  "steam",
  "steamboat",
  "steamer",
  "steel",
  "steep",
  "steeple",
  "steer",
  "stem",
  "step",
  "stepping",
  "stick",
  "sticky",
  "stiff",
  "still",
  "stillness",
  "sting",
  "stir",
  "stitch",
  "stock",
  "stocking",
  "stole",
  "stone",
  "stood",
  "stool",
  "stoop",
  "stop",
  "stopped",
  "stopping",
  "store",
  "stories",
  "stork",
  "storm",
  "stormy",
  "story",
  "stove",
  "straight",
  "strange",
  "stranger",
  "strap",
  "straw",
  "strawberry",
  "stream",
  "street",
  "stretch",
  "string",
  "strip",
  "stripes",
  "strong",
  "stuck",
  "study",
  "stuff",
  "stump",
  "stung",
  "subject",
  "such",
  "suck",
  "sudden",
  "suffer",
  "sugar",
  "suit",
  "sum",
  "summer",
  "sun",
  "sunday",
  "sunflower",
  "sung",
  "sunk",
  "sunlight",
  "sunny",
  "sunrise",
  "sunset",
  "sunshine",
  "supper",
  "suppose",
  "sure",
  "surely",
  "surface",
  "surprise",
  "swallow",
  "swam",
  "swamp",
  "swan",
  "swat",
  "swear",
  "sweat",
  "sweater",
  "sweep",
  "sweet",
  "sweetheart",
  "sweetness",
  "swell",
  "swept",
  "swift",
  "swim",
  "swimming",
  "swing",
  "switch",
  "sword",
  "swore",
  "table",
  "tablecloth",
  "tablespoon",
  "tablet",
  "tack",
  "tag",
  "tail",
  "tailor",
  "take",
  "taken",
  "taking",
  "tale",
  "talk",
  "talker",
  "tall",
  "tame",
  "tan",
  "tank",
  "tap",
  "tape",
  "tar",
  "tardy",
  "task",
  "taste",
  "taught",
  "tax",
  "tea",
  "teach",
  "teacher",
  "team",
  "tear",
  "tease",
  "teaspoon",
  "teeth",
  "telephone",
  "tell",
  "temper",
  "ten",
  "tennis",
  "tent",
  "term",
  "terrible",
  "test",
  "than",
  "thank",
  "thankful",
  "thanks",
  "thanksgiving",
  "that",
  "that's",
  "the",
  "theater",
  "thee",
  "their",
  "them",
  "then",
  "there",
  "these",
  "they",
  "they'd",
  "they'll",
  "they're",
  "they've",
  "thick",
  "thief",
  "thimble",
  "thin",
  "thing",
  "think",
  "third",
  "thirsty",
  "thirteen",
  "thirty",
  "this",
  "thorn",
  "those",
  "though",
  "thought",
  "thousand",
  "thread",
  "three",
  "threw",
  "throat",
  "throne",
  "through",
  "throw",
  "thrown",
  "thumb",
  "thunder",
  "thursday",
  "thy",
  "tick",
  "ticket",
  "tickle",
  "tie",
  "tiger",
  "tight",
  "till",
  "time",
  "tin",
  "tinkle",
  "tiny",
  "tip",
  "tiptoe",
  "tire",
  "tired",
  "title",
  "to",
  "toad",
  "toadstool",
  "toast",
  "tobacco",
  "today",
  "toe",
  "together",
  "toilet",
  "told",
  "tomato",
  "tomorrow",
  "ton",
  "tone",
  "tongue",
  "tonight",
  "too",
  "took",
  "tool",
  "toot",
  "tooth",
  "toothbrush",
  "toothpick",
  "top",
  "tore",
  "torn",
  "toss",
  "touch",
  "tow",
  "toward",
  "towards",
  "towel",
  "tower",
  "town",
  "toy",
  "trace",
  "track",
  "trade",
  "train",
  "tramp",
  "trap",
  "tray",
  "treasure",
  "treat",
  "tree",
  "trick",
  "tricycle",
  "tried",
  "trim",
  "trip",
  "trolley",
  "trouble",
  "truck",
  "true",
  "truly",
  "trunk",
  "trust",
  "truth",
  "try",
  "tub",
  "tuesday",
  "tug",
  "tulip",
  "tumble",
  "tune",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twig",
  "twin",
  "two",
  "ugly",
  "umbrella",
  "uncle",
  "under",
  "understand",
  "underwear",
  "undress",
  "unfair",
  "unfinished",
  "unfold",
  "unfriendly",
  "unhappy",
  "unhurt",
  "uniform",
  "united",
  "unkind",
  "unknown",
  "unless",
  "unpleasant",
  "until",
  "unwilling",
  "up",
  "upon",
  "upper",
  "upset",
  "upside",
  "upstairs",
  "uptown",
  "upward",
  "us",
  "use",
  "used",
  "useful",
  "valentine",
  "valley",
  "valuable",
  "value",
  "vase",
  "vegetable",
  "velvet",
  "very",
  "vessel",
  "victory",
  "view",
  "village",
  "vine",
  "violet",
  "visit",
  "visitor",
  "voice",
  "vote",
  "wag",
  "wagon",
  "waist",
  "wait",
  "wake",
  "waken",
  "walk",
  "wall",
  "walnut",
  "want",
  "war",
  "warm",
  "warn",
  "was",
  "wash",
  "washer",
  "washtub",
  "wasn't",
  "waste",
  "watch",
  "watchman",
  "water",
  "watermelon",
  "waterproof",
  "wave",
  "wax",
  "way",
  "wayside",
  "we",
  "we'd",
  "we'll",
  "we're",
  "we've",
  "weak",
  "weaken",
  "weakness",
  "wealth",
  "weapon",
  "wear",
  "weary",
  "weather",
  "weave",
  "web",
  "wedding",
  "wednesday",
  "wee",
  "weed",
  "week",
  "weep",
  "weigh",
  "welcome",
  "well",
  "went",
  "were",
  "west",
  "western",
  "wet",
  "whale",
  "what",
  "what's",
  "wheat",
  "wheel",
  "when",
  "whenever",
  "where",
  "which",
  "while",
  "whip",
  "whipped",
  "whirl",
  "whiskey",
  "whisky",
  "whisper",
  "whistle",
  "white",
  "who",
  "who'd",
  "who'll",
  "who's",
  "whole",
  "whom",
  "whose",
  "why",
  "wicked",
  "wide",
  "wife",
  "wiggle",
  "wild",
  "wildcat",
  "will",
  "willing",
  "willow",
  "win",
  "wind",
  "windmill",
  "window",
  "windy",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wipe",
  "wire",
  "wise",
  "wish",
  "wit",
  "witch",
  "with",
  "without",
  "woke",
  "wolf",
  "woman",
  "women",
  "won",
  "won't",
  "wonder",
  "wonderful",
  "wood",
  "wooden",
  "woodpecker",
  "woods",
  "wool",
  "woolen",
  "word",
  "wore",
  "work",
  "worker",
  "workman",
  "world",
  "worm",
  "worn",
  "worry",
  "worse",
  "worst",
  "worth",
  "would",
  "wouldn't",
  "wound",
  "wove",
  "wrap",
  "wrapped",
  "wreck",
  "wren",
  "wring",
  "write",
  "writing",
  "written",
  "wrong",
  "wrote",
  "wrung",
  "yard",
  "yarn",
  "year",
  "yell",
  "yellow",
  "yes",
  "yesterday",
  "yet",
  "yolk",
  "yonder",
  "you",
  "you'd",
  "you'll",
  "you're",
  "you've",
  "young",
  "youngster",
  "your",
  "yours",
  "yourself",
  "yourselves",
  "youth"
];

// node_modules/dale-chall-formula/index.js
var difficultWordWeight = 0.1579;
var wordWeight = 0.0496;
var difficultWordThreshold = 0.05;
var percentage2 = 100;
var adjustment = 3.6365;
var gradeMap = {
  4: [0, 4],
  5: [5, 6],
  6: [7, 8],
  7: [9, 10],
  8: [11, 12],
  9: [13, 15],
  10: [16, Number.POSITIVE_INFINITY],
  NaN: [Number.NaN, Number.NaN]
};
function daleChallFormula(counts) {
  if (!counts || !counts.sentence || !counts.word) {
    return Number.NaN;
  }
  const percentageOfDifficultWords = (counts.difficultWord || 0) / counts.word;
  let score = difficultWordWeight * percentageOfDifficultWords * percentage2 + wordWeight * counts.word / counts.sentence;
  if (percentageOfDifficultWords > difficultWordThreshold) {
    score += adjustment;
  }
  return score;
}
function daleChallGradeLevel(score) {
  let floored = Math.floor(score);
  if (floored < 5) {
    floored = 4;
  } else if (floored > 9) {
    floored = 10;
  }
  return gradeMap[floored].concat();
}

// node_modules/flesch/index.js
var sentenceWeight3 = 1.015;
var wordWeight2 = 84.6;
var base4 = 206.835;
function flesch(counts) {
  if (!counts || !counts.sentence || !counts.word || !counts.syllable) {
    return Number.NaN;
  }
  return base4 - sentenceWeight3 * (counts.word / counts.sentence) - wordWeight2 * (counts.syllable / counts.word);
}

// node_modules/gunning-fog/index.js
var complexWordWeight = 100;
var weight = 0.4;
function gunningFog(counts) {
  if (!counts || !counts.sentence || !counts.word) {
    return Number.NaN;
  }
  return weight * (counts.word / counts.sentence + complexWordWeight * ((counts.complexPolysillabicWord || 0) / counts.word));
}

// node_modules/smog-formula/index.js
var sentenceSize = 30;
var weight2 = 1.043;
var base5 = 3.1291;
function smogFormula(counts) {
  if (!counts || !counts.sentence) {
    return Number.NaN;
  }
  return base5 + weight2 * Math.sqrt(
    (counts.polysillabicWord || 0) * (sentenceSize / counts.sentence)
  );
}

// node_modules/spache/index.js
var spache = [
  "a",
  "able",
  "about",
  "above",
  "across",
  "act",
  "add",
  "afraid",
  "after",
  "afternoon",
  "again",
  "against",
  "ago",
  "air",
  "airplane",
  "alarm",
  "all",
  "almost",
  "alone",
  "along",
  "already",
  "also",
  "always",
  "am",
  "among",
  "an",
  "and",
  "angry",
  "animal",
  "another",
  "answer",
  "any",
  "anyone",
  "appear",
  "apple",
  "are",
  "arm",
  "around",
  "arrow",
  "as",
  "ask",
  "asleep",
  "at",
  "ate",
  "attention",
  "aunt",
  "awake",
  "away",
  "b",
  "baby",
  "back",
  "bad",
  "bag",
  "ball",
  "balloon",
  "bang",
  "bank",
  "bark",
  "barn",
  "basket",
  "be",
  "bean",
  "bear",
  "beat",
  "beautiful",
  "became",
  "because",
  "become",
  "bed",
  "bee",
  "been",
  "before",
  "began",
  "begin",
  "behind",
  "believe",
  "bell",
  "belong",
  "bend",
  "bent",
  "beside",
  "best",
  "better",
  "between",
  "big",
  "bird",
  "birthday",
  "bit",
  "bite",
  "black",
  "blanket",
  "blew",
  "block",
  "blow",
  "blue",
  "board",
  "boat",
  "book",
  "boot",
  "born",
  "borrow",
  "both",
  "bother",
  "bottle",
  "bottom",
  "bought",
  "bow",
  "box",
  "boy",
  "branch",
  "brave",
  "bread",
  "break",
  "breakfast",
  "breath",
  "brick",
  "bridge",
  "bright",
  "bring",
  "broke",
  "broken",
  "brother",
  "brought",
  "brown",
  "brush",
  "build",
  "bump",
  "burn",
  "bus",
  "busy",
  "but",
  "butter",
  "button",
  "buy",
  "by",
  "c",
  "cabin",
  "cage",
  "cake",
  "call",
  "came",
  "camp",
  "can",
  "can't",
  "candle",
  "candy",
  "cap",
  "captain",
  "car",
  "card",
  "care",
  "careful",
  "carrot",
  "carry",
  "case",
  "castle",
  "cat",
  "catch",
  "cattle",
  "caught",
  "cause",
  "cent",
  "certain",
  "chair",
  "chance",
  "change",
  "chase",
  "chicken",
  "chief",
  "child",
  "children",
  "church",
  "circle",
  "circus",
  "city",
  "clap",
  "clean",
  "clever",
  "cliff",
  "climb",
  "clock",
  "close",
  "cloth",
  "clothes",
  "clown",
  "coat",
  "cold",
  "color",
  "come",
  "comfortable",
  "company",
  "contest",
  "continue",
  "cook",
  "cool",
  "corner",
  "could",
  "count",
  "country",
  "course",
  "cover",
  "cow",
  "crawl",
  "cream",
  "cry",
  "cup",
  "curtain",
  "cut",
  "d",
  "dad",
  "dance",
  "danger",
  "dangerous",
  "dark",
  "dash",
  "daughter",
  "day",
  "dear",
  "decide",
  "deep",
  "desk",
  "did",
  "didn't",
  "die",
  "different",
  "dig",
  "dinner",
  "direction",
  "disappear",
  "disappoint",
  "discover",
  "distance",
  "do",
  "doctor",
  "does",
  "dog",
  "dollar",
  "don't",
  "done",
  "door",
  "down",
  "dragon",
  "dream",
  "dress",
  "drink",
  "drive",
  "drop",
  "drove",
  "dry",
  "duck",
  "during",
  "dust",
  "e",
  "each",
  "eager",
  "ear",
  "early",
  "earn",
  "earth",
  "easy",
  "eat",
  "edge",
  "egg",
  "eight",
  "eighteen",
  "either",
  "elephant",
  "else",
  "empty",
  "end",
  "enemy",
  "enough",
  "enter",
  "even",
  "ever",
  "every",
  "everything",
  "exact",
  "except",
  "excite",
  "exclaim",
  "explain",
  "eye",
  "face",
  "fact",
  "fair",
  "fall",
  "family",
  "far",
  "farm",
  "farmer",
  "farther",
  "fast",
  "fat",
  "father",
  "feather",
  "feed",
  "feel",
  "feet",
  "fell",
  "fellow",
  "felt",
  "fence",
  "few",
  "field",
  "fierce",
  "fight",
  "figure",
  "fill",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "first",
  "fish",
  "five",
  "flag",
  "flash",
  "flat",
  "flew",
  "floor",
  "flower",
  "fly",
  "follow",
  "food",
  "for",
  "forest",
  "forget",
  "forth",
  "found",
  "four",
  "fourth",
  "fox",
  "fresh",
  "friend",
  "frighten",
  "frog",
  "from",
  "front",
  "fruit",
  "full",
  "fun",
  "funny",
  "fur",
  "g",
  "game",
  "garden",
  "gasp",
  "gate",
  "gave",
  "get",
  "giant",
  "gift",
  "girl",
  "give",
  "glad",
  "glass",
  "go",
  "goat",
  "gone",
  "good",
  "got",
  "grandfather",
  "grandmother",
  "grass",
  "gray",
  "great",
  "green",
  "grew",
  "grin",
  "ground",
  "group",
  "grow",
  "growl",
  "guess",
  "gun",
  "h",
  "had",
  "hair",
  "half",
  "hall",
  "hand",
  "handle",
  "hang",
  "happen",
  "happiness",
  "happy",
  "hard",
  "harm",
  "has",
  "hat",
  "hate",
  "have",
  "he",
  "he's",
  "head",
  "hear",
  "heard",
  "heavy",
  "held",
  "hello",
  "help",
  "hen",
  "her",
  "here",
  "herself",
  "hid",
  "hide",
  "high",
  "hill",
  "him",
  "himself",
  "his",
  "hit",
  "hold",
  "hole",
  "holiday",
  "home",
  "honey",
  "hop",
  "horn",
  "horse",
  "hot",
  "hour",
  "house",
  "how",
  "howl",
  "hum",
  "hundred",
  "hung",
  "hungry",
  "hunt",
  "hurry",
  "hurt",
  "husband",
  "i",
  "i'll",
  "i'm",
  "ice",
  "idea",
  "if",
  "imagine",
  "important",
  "in",
  "inch",
  "indeed",
  "inside",
  "instead",
  "into",
  "invite",
  "is",
  "it",
  "it's",
  "its",
  "j",
  "jacket",
  "jar",
  "jet",
  "job",
  "join",
  "joke",
  "joy",
  "jump",
  "just",
  "k",
  "keep",
  "kept",
  "key",
  "kick",
  "kill",
  "kind",
  "king",
  "kitchen",
  "kitten",
  "knee",
  "knew",
  "knock",
  "know",
  "l",
  "ladder",
  "lady",
  "laid",
  "lake",
  "land",
  "large",
  "last",
  "late",
  "laugh",
  "lay",
  "lazy",
  "lead",
  "leap",
  "learn",
  "least",
  "leave",
  "left",
  "leg",
  "less",
  "let",
  "let's",
  "letter",
  "lick",
  "lift",
  "light",
  "like",
  "line",
  "lion",
  "list",
  "listen",
  "little",
  "live",
  "load",
  "long",
  "look",
  "lost",
  "lot",
  "loud",
  "love",
  "low",
  "luck",
  "lump",
  "lunch",
  "m",
  "machine",
  "made",
  "magic",
  "mail",
  "make",
  "man",
  "many",
  "march",
  "mark",
  "market",
  "master",
  "matter",
  "may",
  "maybe",
  "me",
  "mean",
  "meant",
  "meat",
  "meet",
  "melt",
  "men",
  "merry",
  "met",
  "middle",
  "might",
  "mile",
  "milk",
  "milkman",
  "mind",
  "mine",
  "minute",
  "miss",
  "mistake",
  "moment",
  "money",
  "monkey",
  "month",
  "more",
  "morning",
  "most",
  "mother",
  "mountain",
  "mouse",
  "mouth",
  "move",
  "much",
  "mud",
  "music",
  "must",
  "my",
  "n",
  "name",
  "near",
  "neck",
  "need",
  "needle",
  "neighbor",
  "neighborhood",
  "nest",
  "never",
  "new",
  "next",
  "nibble",
  "nice",
  "night",
  "nine",
  "no",
  "nod",
  "noise",
  "none",
  "north",
  "nose",
  "not",
  "note",
  "nothing",
  "notice",
  "now",
  "number",
  "o",
  "ocean",
  "of",
  "off",
  "offer",
  "often",
  "oh",
  "old",
  "on",
  "once",
  "one",
  "only",
  "open",
  "or",
  "orange",
  "order",
  "other",
  "our",
  "out",
  "outside",
  "over",
  "owl",
  "own",
  "p",
  "pack",
  "paid",
  "pail",
  "paint",
  "pair",
  "palace",
  "pan",
  "paper",
  "parade",
  "parent",
  "park",
  "part",
  "party",
  "pass",
  "past",
  "pasture",
  "path",
  "paw",
  "pay",
  "peanut",
  "peek",
  "pen",
  "penny",
  "people",
  "perfect",
  "perhaps",
  "person",
  "pet",
  "pick",
  "picket",
  "picnic",
  "picture",
  "pie",
  "piece",
  "pig",
  "pile",
  "pin",
  "place",
  "plan",
  "plant",
  "play",
  "pleasant",
  "please",
  "plenty",
  "plow",
  "point",
  "poke",
  "pole",
  "policeman",
  "pond",
  "poor",
  "pop",
  "postman",
  "pot",
  "potato",
  "pound",
  "pour",
  "practice",
  "prepare",
  "present",
  "pretend",
  "pretty",
  "princess",
  "prize",
  "probably",
  "problem",
  "promise",
  "protect",
  "proud",
  "puff",
  "pull",
  "puppy",
  "push",
  "put",
  "q",
  "queen",
  "queer",
  "quick",
  "quiet",
  "quite",
  "r",
  "rabbit",
  "raccoon",
  "race",
  "radio",
  "rag",
  "rain",
  "raise",
  "ran",
  "ranch",
  "rang",
  "reach",
  "read",
  "ready",
  "real",
  "red",
  "refuse",
  "remember",
  "reply",
  "rest",
  "return",
  "reward",
  "rich",
  "ride",
  "right",
  "ring",
  "river",
  "road",
  "roar",
  "rock",
  "rode",
  "roll",
  "roof",
  "room",
  "rope",
  "round",
  "row",
  "rub",
  "rule",
  "run",
  "rush",
  "s",
  "sad",
  "safe",
  "said",
  "sail",
  "sale",
  "salt",
  "same",
  "sand",
  "sang",
  "sat",
  "save",
  "saw",
  "say",
  "scare",
  "school",
  "scold",
  "scratch",
  "scream",
  "sea",
  "seat",
  "second",
  "secret",
  "see",
  "seed",
  "seem",
  "seen",
  "sell",
  "send",
  "sent",
  "seven",
  "several",
  "sew",
  "shadow",
  "shake",
  "shall",
  "shape",
  "she",
  "sheep",
  "shell",
  "shine",
  "ship",
  "shoe",
  "shone",
  "shook",
  "shoot",
  "shop",
  "shore",
  "short",
  "shot",
  "should",
  "show",
  "sick",
  "side",
  "sight",
  "sign",
  "signal",
  "silent",
  "silly",
  "silver",
  "since",
  "sing",
  "sister",
  "sit",
  "six",
  "size",
  "skip",
  "sky",
  "sled",
  "sleep",
  "slid",
  "slide",
  "slow",
  "small",
  "smart",
  "smell",
  "smile",
  "smoke",
  "snap",
  "sniff",
  "snow",
  "so",
  "soft",
  "sold",
  "some",
  "something",
  "sometimes",
  "son",
  "song",
  "soon",
  "sorry",
  "sound",
  "speak",
  "special",
  "spend",
  "spill",
  "splash",
  "spoke",
  "spot",
  "spread",
  "spring",
  "squirrel",
  "stand",
  "star",
  "start",
  "station",
  "stay",
  "step",
  "stick",
  "still",
  "stone",
  "stood",
  "stop",
  "store",
  "story",
  "straight",
  "strange",
  "street",
  "stretch",
  "strike",
  "strong",
  "such",
  "sudden",
  "sugar",
  "suit",
  "summer",
  "sun",
  "supper",
  "suppose",
  "sure",
  "surprise",
  "swallow",
  "sweet",
  "swim",
  "swing",
  "t",
  "table",
  "tail",
  "take",
  "talk",
  "tall",
  "tap",
  "taste",
  "teach",
  "teacher",
  "team",
  "tear",
  "teeth",
  "telephone",
  "tell",
  "ten",
  "tent",
  "than",
  "thank",
  "that",
  "that's",
  "the",
  "their",
  "them",
  "then",
  "there",
  "these",
  "they",
  "thick",
  "thin",
  "thing",
  "think",
  "third",
  "this",
  "those",
  "though",
  "thought",
  "three",
  "threw",
  "through",
  "throw",
  "tie",
  "tiger",
  "tight",
  "time",
  "tiny",
  "tip",
  "tire",
  "to",
  "today",
  "toe",
  "together",
  "told",
  "tomorrow",
  "too",
  "took",
  "tooth",
  "top",
  "touch",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "traffic",
  "train",
  "trap",
  "tree",
  "trick",
  "trip",
  "trot",
  "truck",
  "true",
  "trunk",
  "try",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twin",
  "two",
  "u",
  "ugly",
  "uncle",
  "under",
  "unhappy",
  "until",
  "up",
  "upon",
  "upstairs",
  "us",
  "use",
  "usual",
  "v",
  "valley",
  "vegetable",
  "very",
  "village",
  "visit",
  "voice",
  "w",
  "wag",
  "wagon",
  "wait",
  "wake",
  "walk",
  "want",
  "war",
  "warm",
  "was",
  "wash",
  "waste",
  "watch",
  "water",
  "wave",
  "way",
  "we",
  "wear",
  "weather",
  "week",
  "well",
  "went",
  "were",
  "wet",
  "what",
  "wheel",
  "when",
  "where",
  "which",
  "while",
  "whisper",
  "whistle",
  "white",
  "who",
  "whole",
  "whose",
  "why",
  "wide",
  "wife",
  "will",
  "win",
  "wind",
  "window",
  "wing",
  "wink",
  "winter",
  "wire",
  "wise",
  "wish",
  "with",
  "without",
  "woke",
  "wolf",
  "woman",
  "women",
  "won't",
  "wonder",
  "wood",
  "word",
  "wore",
  "work",
  "world",
  "worm",
  "worry",
  "worth",
  "would",
  "wrong",
  "x",
  "y",
  "yard",
  "year",
  "yell",
  "yellow",
  "yes",
  "yet",
  "you",
  "young",
  "your",
  "z",
  "zoo"
];

// node_modules/spache-formula/index.js
var sentenceWeight4 = 0.121;
var wordWeight3 = 0.082;
var percentage3 = 100;
var base6 = 0.659;
function spacheFormula(counts) {
  if (!counts || !counts.sentence || !counts.word) {
    return Number.NaN;
  }
  return base6 + sentenceWeight4 * counts.word / counts.sentence + wordWeight3 * (counts.unfamiliarWord || 0) / counts.word * percentage3;
}

// node_modules/syllable/index.js
var import_pluralize = __toESM(require_pluralize(), 1);
var import_normalize_strings = __toESM(require_normalize_strings(), 1);

// node_modules/syllable/problematic.js
var problematic = {
  abalone: 4,
  abare: 3,
  abbruzzese: 4,
  abed: 2,
  aborigine: 5,
  abruzzese: 4,
  acreage: 3,
  adame: 3,
  adieu: 2,
  adobe: 3,
  anemone: 4,
  anyone: 3,
  apache: 3,
  aphrodite: 4,
  apostrophe: 4,
  ariadne: 4,
  cafe: 2,
  calliope: 4,
  catastrophe: 4,
  chile: 2,
  chloe: 2,
  circe: 2,
  coyote: 3,
  daphne: 2,
  epitome: 4,
  eurydice: 4,
  euterpe: 3,
  every: 2,
  everywhere: 3,
  forever: 3,
  gethsemane: 4,
  guacamole: 4,
  hermione: 4,
  hyperbole: 4,
  jesse: 2,
  jukebox: 2,
  karate: 3,
  machete: 3,
  maybe: 2,
  naive: 2,
  newlywed: 3,
  penelope: 4,
  people: 2,
  persephone: 4,
  phoebe: 2,
  pulse: 1,
  queue: 1,
  recipe: 3,
  riverbed: 3,
  sesame: 3,
  shoreline: 2,
  simile: 3,
  snuffleupagus: 5,
  sometimes: 2,
  syncope: 3,
  tamale: 3,
  waterbed: 3,
  wednesday: 2,
  yosemite: 4,
  zoe: 2
};

// node_modules/syllable/index.js
var own3 = {}.hasOwnProperty;
var EXPRESSION_MONOSYLLABIC_ONE = new RegExp(
  [
    "awe($|d|so)",
    "cia(?:l|$)",
    "tia",
    "cius",
    "cious",
    "[^aeiou]giu",
    "[aeiouy][^aeiouy]ion",
    "iou",
    "sia$",
    "eous$",
    "[oa]gue$",
    ".[^aeiuoycgltdb]{2,}ed$",
    ".ely$",
    "^jua",
    "uai",
    "eau",
    "^busi$",
    "(?:[aeiouy](?:" + [
      "[bcfgklmnprsvwxyz]",
      "ch",
      "dg",
      "g[hn]",
      "lch",
      "l[lv]",
      "mm",
      "nch",
      "n[cgn]",
      "r[bcnsv]",
      "squ",
      "s[chkls]",
      "th"
    ].join("|") + ")ed$)",
    "(?:[aeiouy](?:" + [
      "[bdfklmnprstvy]",
      "ch",
      "g[hn]",
      "lch",
      "l[lv]",
      "mm",
      "nch",
      "nn",
      "r[nsv]",
      "squ",
      "s[cklst]",
      "th"
    ].join("|") + ")es$)"
  ].join("|"),
  "g"
);
var EXPRESSION_MONOSYLLABIC_TWO = new RegExp(
  "[aeiouy](?:" + [
    "[bcdfgklmnprstvyz]",
    "ch",
    "dg",
    "g[hn]",
    "l[lv]",
    "mm",
    "n[cgns]",
    "r[cnsv]",
    "squ",
    "s[cklst]",
    "th"
  ].join("|") + ")e$",
  "g"
);
var EXPRESSION_DOUBLE_SYLLABIC_ONE = new RegExp(
  "(?:" + [
    "([^aeiouy])\\1l",
    "[^aeiouy]ie(?:r|s?t)",
    "[aeiouym]bl",
    "eo",
    "ism",
    "asm",
    "thm",
    "dnt",
    "snt",
    "uity",
    "dea",
    "gean",
    "oa",
    "ua",
    "react?",
    "orbed",
    // Cancel `'.[^aeiuoycgltdb]{2,}ed$',`
    "shred",
    // Cancel `'.[^aeiuoycgltdb]{2,}ed$',`
    "eings?",
    "[aeiouy]sh?e[rs]"
  ].join("|") + ")$",
  "g"
);
var EXPRESSION_DOUBLE_SYLLABIC_TWO = new RegExp(
  [
    "creat(?!u)",
    "[^gq]ua[^auieo]",
    "[aeiou]{3}",
    "^(?:ia|mc|coa[dglx].)",
    "^re(app|es|im|us)",
    "(th|d)eist"
  ].join("|"),
  "g"
);
var EXPRESSION_DOUBLE_SYLLABIC_THREE = new RegExp(
  [
    "[^aeiou]y[ae]",
    "[^l]lien",
    "riet",
    "dien",
    "iu",
    "io",
    "ii",
    "uen",
    "[aeilotu]real",
    "real[aeilotu]",
    "iell",
    "eo[^aeiou]",
    "[aeiou]y[aeiou]"
  ].join("|"),
  "g"
);
var EXPRESSION_DOUBLE_SYLLABIC_FOUR = /[^s]ia/;
var EXPRESSION_SINGLE = new RegExp(
  [
    "^(?:" + [
      "un",
      "fore",
      "ware",
      "none?",
      "out",
      "post",
      "sub",
      "pre",
      "pro",
      "dis",
      "side",
      "some"
    ].join("|") + ")",
    "(?:" + [
      "ly",
      "less",
      "some",
      "ful",
      "ers?",
      "ness",
      "cians?",
      "ments?",
      "ettes?",
      "villes?",
      "ships?",
      "sides?",
      "ports?",
      "shires?",
      "[gnst]ion(?:ed|s)?"
    ].join("|") + ")$"
  ].join("|"),
  "g"
);
var EXPRESSION_DOUBLE = new RegExp(
  [
    "^(?:" + [
      "above",
      "anti",
      "ante",
      "counter",
      "hyper",
      "afore",
      "agri",
      "infra",
      "intra",
      "inter",
      "over",
      "semi",
      "ultra",
      "under",
      "extra",
      "dia",
      "micro",
      "mega",
      "kilo",
      "pico",
      "nano",
      "macro",
      "somer"
    ].join("|") + ")",
    "(?:fully|berry|woman|women|edly|union|((?:[bcdfghjklmnpqrstvwxz])|[aeiou])ye?ing)$"
  ].join("|"),
  "g"
);
var EXPRESSION_TRIPLE = /(creations?|ology|ologist|onomy|onomist)$/g;
function syllable(value) {
  const values = (0, import_normalize_strings.default)(String(value)).toLowerCase().replace(/['’]/g, "").split(/\b/g);
  let index2 = -1;
  let sum = 0;
  while (++index2 < values.length) {
    sum += one(values[index2].replace(/[^a-z]/g, ""));
  }
  return sum;
}
function one(value) {
  let count = 0;
  if (value.length === 0) {
    return count;
  }
  if (value.length < 3) {
    return 1;
  }
  if (own3.call(problematic, value)) {
    return problematic[value];
  }
  const singular = (0, import_pluralize.default)(value, 1);
  if (own3.call(problematic, singular)) {
    return problematic[singular];
  }
  const addOne = returnFactory(1);
  const subtractOne = returnFactory(-1);
  value = value.replace(EXPRESSION_TRIPLE, countFactory(3)).replace(EXPRESSION_DOUBLE, countFactory(2)).replace(EXPRESSION_SINGLE, countFactory(1));
  const parts = value.split(/[^aeiouy]+/);
  let index2 = -1;
  while (++index2 < parts.length) {
    if (parts[index2] !== "") {
      count++;
    }
  }
  value.replace(EXPRESSION_MONOSYLLABIC_ONE, subtractOne).replace(EXPRESSION_MONOSYLLABIC_TWO, subtractOne);
  value.replace(EXPRESSION_DOUBLE_SYLLABIC_ONE, addOne).replace(EXPRESSION_DOUBLE_SYLLABIC_TWO, addOne).replace(EXPRESSION_DOUBLE_SYLLABIC_THREE, addOne).replace(EXPRESSION_DOUBLE_SYLLABIC_FOUR, addOne);
  return count || 1;
  function countFactory(addition) {
    return counter;
    function counter() {
      count += addition;
      return "";
    }
  }
  function returnFactory(addition) {
    return returner;
    function returner($0) {
      count += addition;
      return $0;
    }
  }
}

// node_modules/retext-readability/index.js
var origin = "retext-readability:readability";
var url2 = "https://github.com/retextjs/retext-readability#readme";
var defaultTargetAge = 16;
var defaultWordynessThreshold = 5;
var defaultThreshold = 4 / 7;
var own4 = {}.hasOwnProperty;
var floor = Math.floor;
var round = Math.round;
var ceil = Math.ceil;
var sqrt = Math.sqrt;
function retextReadability(options = {}) {
  const targetAge = options.age || defaultTargetAge;
  const threshold = options.threshold || defaultThreshold;
  const minWords = options.minWords === null || options.minWords === void 0 ? defaultWordynessThreshold : options.minWords;
  return (tree, file) => {
    visit(tree, "SentenceNode", (sentence) => {
      const familiarWords = {};
      const easyWord = {};
      let complexPolysillabicWord = 0;
      let familiarWordCount = 0;
      let polysillabicWord = 0;
      let totalSyllables = 0;
      let easyWordCount = 0;
      let wordCount = 0;
      let letters = 0;
      visit(sentence, "WordNode", (node) => {
        const value = toString(node);
        const caseless = value.toLowerCase();
        const syllables = syllable(value);
        wordCount++;
        totalSyllables += syllables;
        letters += value.length;
        if (syllables >= 3) {
          polysillabicWord++;
          if (value.charCodeAt(0) === caseless.charCodeAt(0)) {
            complexPolysillabicWord++;
          }
        }
        if (spache.includes(caseless) && !own4.call(familiarWords, caseless)) {
          familiarWords[caseless] = true;
          familiarWordCount++;
        }
        if (daleChall.includes(caseless) && !own4.call(easyWord, caseless)) {
          easyWord[caseless] = true;
          easyWordCount++;
        }
      });
      if (wordCount >= minWords) {
        const counts = {
          complexPolysillabicWord,
          polysillabicWord,
          unfamiliarWord: wordCount - familiarWordCount,
          difficultWord: wordCount - easyWordCount,
          syllable: totalSyllables,
          sentence: 1,
          word: wordCount,
          character: letters,
          letter: letters
        };
        const scores = [
          gradeToAge(daleChallGradeLevel(daleChallFormula(counts))[1]),
          gradeToAge(automatedReadability(counts)),
          gradeToAge(colemanLiau(counts)),
          fleschToAge(flesch(counts)),
          smogToAge(smogFormula(counts)),
          gradeToAge(gunningFog(counts)),
          gradeToAge(spacheFormula(counts))
        ];
        let index2 = -1;
        let failCount = 0;
        while (++index2 < scores.length) {
          if (scores[index2] > targetAge) {
            failCount++;
          }
        }
        const confidence = failCount / scores.length;
        if (confidence >= threshold) {
          const label = failCount + "/" + scores.length;
          Object.assign(
            file.message(
              "Hard to read sentence (confidence: " + label + ")",
              sentence,
              origin
            ),
            {
              actual: toString(sentence),
              expected: [],
              url: url2,
              confidence,
              confidenceLabel: label
            }
          );
        }
      }
      return SKIP;
    });
  };
}
function gradeToAge(grade) {
  return round(grade + 5);
}
function fleschToAge(value) {
  return 20 - floor(value / 10);
}
function smogToAge(value) {
  return ceil(sqrt(value) + 2.5);
}

// node_modules/unist-util-find-before/lib/index.js
var findBefore = (
  /**
   * @type {(
   *  (<T extends Node>(node: Parent, index: Node | number, test: import('unist-util-is').PredicateTest<T>) => T | null) &
   *  ((node: Parent, index: Node | number, test?: Test) => Node | null)
   * )}
   */
  /**
   * @param {Parent} parent
   * @param {Node | number} index
   * @param {Test} [test]
   * @returns {Node | null}
   */
  function(parent, index2, test) {
    const is2 = convert(test);
    if (!parent || !parent.type || !parent.children) {
      throw new Error("Expected parent node");
    }
    if (typeof index2 === "number") {
      if (index2 < 0 || index2 === Number.POSITIVE_INFINITY) {
        throw new Error("Expected positive finite number as index");
      }
    } else {
      index2 = parent.children.indexOf(index2);
      if (index2 < 0) {
        throw new Error("Expected child node or index");
      }
    }
    if (index2 > parent.children.length) {
      index2 = parent.children.length;
    }
    while (index2--) {
      if (is2(parent.children[index2], index2, parent)) {
        return parent.children[index2];
      }
    }
    return null;
  }
);

// node_modules/retext-passive/list.js
var list2 = [
  "awoken",
  "awoke",
  "beaten",
  "beat",
  "begun",
  "began",
  "bent",
  "bitten",
  "bit",
  "bled",
  "blown",
  "blew",
  "broken",
  "broke",
  "brought",
  "built",
  "bought",
  "caught",
  "chosen",
  "chose",
  "dealt",
  "done",
  "did",
  "drawn",
  "drew",
  "driven",
  "drove",
  "eaten",
  "ate",
  "fed",
  "felt",
  "fought",
  "found",
  "forbidden",
  "forbade",
  "forgotten",
  "forgot",
  "forgiven",
  "forgave",
  "frozen",
  "froze",
  "gotten",
  "got",
  "given",
  "gave",
  "ground",
  "grinded",
  "hung",
  "heard",
  "hidden",
  "hid",
  "hit",
  "held",
  "hurt",
  "kept",
  "known",
  "knew",
  "laid",
  "led",
  "let",
  "lost",
  "made",
  "meant",
  "met",
  "paid",
  "proven",
  "proved",
  "put",
  "read",
  "ridden",
  "rode",
  "rung",
  "rang",
  "run",
  "ran",
  "said",
  "seen",
  "saw",
  "sold",
  "sent",
  "shaken",
  "shook",
  "shaved",
  "shot",
  "shown",
  "shut",
  "sung",
  "sunk",
  "slain",
  "slew",
  "slid",
  "spoken",
  "spoke",
  "spent",
  "spun",
  "split",
  "spread",
  "stolen",
  "stole",
  "struck",
  "swept",
  "swung",
  "taken",
  "took",
  "taught",
  "torn",
  "tore",
  "told",
  "thought",
  "thrown",
  "threw",
  "undergone",
  "underwent",
  "understood",
  "upset",
  "woken",
  "woke",
  "worn",
  "wore",
  "won",
  "withdrawn",
  "withdrew",
  "written",
  "wrote",
  "been",
  "born",
  "become",
  "beset",
  "bet",
  "bid",
  "bidden",
  "bound",
  "bred",
  "broadcast",
  "burnt",
  "burst",
  "cast",
  "clung",
  "come",
  "cost",
  "crept",
  "cut",
  "dug",
  "dived",
  "dreamt",
  "drunk",
  "fallen",
  "fit",
  "fled",
  "flung",
  "flown",
  "foregone",
  "forsaken",
  "gone",
  "grown",
  "knelt",
  "knit",
  "leapt",
  "learnt",
  "left",
  "lent",
  "lain",
  "lighted",
  "misspelt",
  "mistaken",
  "mown",
  "overcome",
  "overdone",
  "overtaken",
  "overthrown",
  "pled",
  "quit",
  "rid",
  "risen",
  "sawn",
  "sought",
  "set",
  "sewn",
  "shaven",
  "shorn",
  "shed",
  "shone",
  "shod",
  "shrunk",
  "sat",
  "slept",
  "slung",
  "slit",
  "smitten",
  "sown",
  "sped",
  "spilt",
  "spit",
  "sprung",
  "stood",
  "stuck",
  "stung",
  "stunk",
  "stridden",
  "strung",
  "striven",
  "sworn",
  "swollen",
  "swum",
  "thrived",
  "thrust",
  "trodden",
  "upheld",
  "woven",
  "wed",
  "wept",
  "wound",
  "withheld",
  "withstood",
  "wrung"
];

// node_modules/retext-passive/index.js
var source2 = "retext-passive";
var url3 = "https://github.com/retextjs/retext-passive#readme";
var verbs = /* @__PURE__ */ new Set(["am", "are", "were", "being", "is", "been", "was", "be"]);
function retextPassive(options = {}) {
  const ignore = options.ignore || [];
  const phrases = ignore.length > 0 ? list2.filter((d) => !ignore.includes(d)) : list2;
  return (tree, file) => {
    search(tree, phrases, (match, index2, parent, phrase) => {
      const before = (
        /** @type {Word} */
        findBefore(parent, index2, "WordNode")
      );
      if (!before || !verbs.has(toString(before).toLowerCase())) {
        return;
      }
      Object.assign(
        file.message(
          "Don\u2019t use the passive voice",
          { start: pointStart(match[0]), end: pointEnd(match[match.length - 1]) },
          [source2, phrase.replace(/\s+/g, "-").toLowerCase()].join(":")
        ),
        { actual: toString(match), expected: [], url: url3 }
      );
    });
  };
}

// node_modules/retext-simplify/patterns.js
var patterns = {
  "a number of": {
    replace: ["many", "some"]
  },
  abundance: {
    replace: ["enough", "plenty"]
  },
  "accede to": {
    replace: ["agree to", "allow"]
  },
  accelerate: {
    replace: ["speed up"]
  },
  accentuate: {
    replace: ["stress"]
  },
  accompany: {
    replace: ["go with", "with"]
  },
  accomplish: {
    replace: ["carry out", "do"]
  },
  accorded: {
    replace: ["given"]
  },
  accordingly: {
    replace: ["so"]
  },
  accrue: {
    replace: ["add", "gain"]
  },
  accurate: {
    replace: ["correct", "exact", "right"]
  },
  acquiesce: {
    replace: ["agree"]
  },
  acquire: {
    replace: ["get"]
  },
  additional: {
    replace: ["added", "extra", "more", "other"]
  },
  address: {
    replace: ["discuss"]
  },
  addressees: {
    replace: ["you"]
  },
  "addressees are requested": {
    omit: true,
    replace: ["please"]
  },
  "adjacent to": {
    replace: ["next to"]
  },
  adjustment: {
    replace: ["change"]
  },
  admissible: {
    replace: ["accepted", "allowed"]
  },
  advantageous: {
    replace: ["helpful"]
  },
  "adversely impact": {
    replace: ["hurt"]
  },
  "adversely impact on": {
    replace: ["hurt", "set back"]
  },
  advise: {
    replace: ["recommend", "tell"]
  },
  "afford an opportunity": {
    replace: ["allow", "let"]
  },
  aforementioned: {
    replace: ["remove"]
  },
  aggregate: {
    replace: ["add", "total"]
  },
  aircraft: {
    replace: ["plane"]
  },
  "all of": {
    replace: ["all"]
  },
  alleviate: {
    replace: ["ease", "reduce"]
  },
  allocate: {
    replace: ["divide"]
  },
  "along the lines of": {
    replace: ["as in", "like"]
  },
  "already existing": {
    replace: ["existing"]
  },
  alternatively: {
    replace: ["or"]
  },
  ameliorate: {
    replace: ["help", "improve"]
  },
  "and/or": {
    replace: ["\u2026 or \u2026 or both"]
  },
  anticipate: {
    replace: ["expect"]
  },
  apparent: {
    replace: ["clear", "plain"]
  },
  appreciable: {
    replace: ["many"]
  },
  appropriate: {
    omit: true,
    replace: ["proper", "right"]
  },
  approximate: {
    replace: ["about"]
  },
  "arrive onboard": {
    replace: ["arrive"]
  },
  "as a means of": {
    replace: ["to"]
  },
  "as of yet": {
    replace: ["yet"]
  },
  "as prescribed by": {
    replace: ["in"]
  },
  "as to": {
    replace: ["about", "on"]
  },
  "as yet": {
    replace: ["yet"]
  },
  ascertain: {
    replace: ["find out", "learn"]
  },
  assist: {
    replace: ["aid", "help"]
  },
  assistance: {
    replace: ["aid", "help"]
  },
  "at the present time": {
    replace: ["at present"]
  },
  "at this time": {
    replace: ["now"]
  },
  attain: {
    replace: ["meet"]
  },
  attempt: {
    replace: ["try"]
  },
  "attributable to": {
    replace: ["because"]
  },
  authorise: {
    replace: ["allow", "let"]
  },
  authorize: {
    replace: ["allow", "let"]
  },
  "be advised": {
    omit: true,
    replace: []
  },
  "because of the fact that": {
    replace: ["because"]
  },
  belated: {
    replace: ["late"]
  },
  benefit: {
    replace: ["help"]
  },
  "benefit from": {
    replace: ["enjoy"]
  },
  bestow: {
    replace: ["award", "give"]
  },
  "by means of": {
    replace: ["by", "with"]
  },
  "by virtue of": {
    replace: ["by", "under"]
  },
  capability: {
    replace: ["ability"]
  },
  caveat: {
    replace: ["warning"]
  },
  cease: {
    replace: ["stop"]
  },
  "close proximity": {
    replace: ["near"]
  },
  "combat environment": {
    replace: ["combat"]
  },
  combined: {
    replace: ["joint"]
  },
  commence: {
    replace: ["begin", "start"]
  },
  "comply with": {
    replace: ["follow"]
  },
  component: {
    replace: ["part"]
  },
  comprise: {
    replace: ["form", "include", "make up"]
  },
  concerning: {
    replace: ["about", "on"]
  },
  consequently: {
    replace: ["so"]
  },
  consolidate: {
    replace: ["combine", "join", "merge"]
  },
  constitutes: {
    replace: ["forms", "is", "makes up"]
  },
  contains: {
    replace: ["has"]
  },
  convene: {
    replace: ["meet"]
  },
  currently: {
    omit: true,
    replace: ["now"]
  },
  deem: {
    replace: ["believe", "consider", "think"]
  },
  delete: {
    replace: ["cut", "drop"]
  },
  demonstrate: {
    replace: ["prove", "show"]
  },
  depart: {
    replace: ["go", "leave"]
  },
  designate: {
    replace: ["appoint", "choose", "name"]
  },
  desire: {
    replace: ["want", "wish"]
  },
  determine: {
    replace: ["decide", "figure", "find"]
  },
  disclose: {
    replace: ["show"]
  },
  discontinue: {
    replace: ["drop", "stop"]
  },
  disseminate: {
    replace: ["give", "issue", "pass", "send"]
  },
  "due to the fact that": {
    replace: ["because", "due to", "since"]
  },
  "during the period": {
    replace: ["during"]
  },
  "e.g.": {
    replace: ["for example", "such as"]
  },
  "each and every": {
    replace: ["each"]
  },
  economical: {
    replace: ["cheap"]
  },
  effect: {
    replace: ["choose", "pick", "result"]
  },
  "effect modifications": {
    replace: ["make changes"]
  },
  elect: {
    replace: ["choose"]
  },
  eliminate: {
    replace: ["cut", "drop", "end", "stop"]
  },
  elucidate: {
    replace: ["explain"]
  },
  employ: {
    replace: ["use"]
  },
  encounter: {
    replace: ["meet"]
  },
  endeavor: {
    replace: ["try"]
  },
  ensure: {
    replace: ["make sure"]
  },
  enumerate: {
    replace: ["count"]
  },
  equipments: {
    replace: ["equipment"]
  },
  equitable: {
    replace: ["fair"]
  },
  equivalent: {
    replace: ["equal"]
  },
  establish: {
    replace: ["set up", "prove", "show"]
  },
  evaluate: {
    replace: ["check", "test"]
  },
  evidenced: {
    replace: ["showed"]
  },
  evident: {
    replace: ["clear"]
  },
  exclusively: {
    replace: ["only"]
  },
  exhibit: {
    replace: ["show"]
  },
  expedite: {
    replace: ["hasten", "hurry", "speed up"]
  },
  expeditious: {
    replace: ["fast", "quick"]
  },
  expend: {
    replace: ["spend"]
  },
  expertise: {
    replace: ["ability"]
  },
  expiration: {
    replace: ["end"]
  },
  facilitate: {
    replace: ["ease", "help"]
  },
  "factual evidence": {
    replace: ["evidence", "facts"]
  },
  "failed to": {
    replace: ["didn\u2019t"]
  },
  feasible: {
    replace: ["can be done", "workable"]
  },
  females: {
    replace: ["women"]
  },
  finalise: {
    replace: ["complete", "finish"]
  },
  finalize: {
    replace: ["complete", "finish"]
  },
  "first and foremost": {
    replace: ["first"]
  },
  "for a period of": {
    replace: ["for"]
  },
  "for the purpose of": {
    replace: ["to"]
  },
  forfeit: {
    replace: ["give up", "lose"]
  },
  formulate: {
    replace: ["plan"]
  },
  forward: {
    replace: ["send"]
  },
  frequently: {
    replace: ["often"]
  },
  function: {
    replace: ["act", "role", "work"]
  },
  furnish: {
    replace: ["give", "send"]
  },
  "has a requirement for": {
    replace: ["needs"]
  },
  "has no effect": {
    replace: ["does nothing", "does not apply"]
  },
  herein: {
    replace: ["here"]
  },
  heretofore: {
    replace: ["until now"]
  },
  herewith: {
    replace: ["here", "below"]
  },
  "honest truth": {
    replace: ["truth"]
  },
  however: {
    replace: ["but", "yet"]
  },
  "i.e.": {
    replace: ["as in"]
  },
  identical: {
    replace: ["same"]
  },
  identify: {
    replace: ["find", "name", "show"]
  },
  "if and when": {
    replace: ["if", "when"]
  },
  immediately: {
    replace: ["at once"]
  },
  impacted: {
    replace: ["affected", "changed", "harmed"]
  },
  implement: {
    replace: ["carry out", "install", "put in place", "tool", "start"]
  },
  "in a timely manner": {
    replace: ["on time", "promptly"]
  },
  "in accordance with": {
    replace: ["by", "under", "following", "per"]
  },
  "in addition": {
    replace: ["also", "besides", "too"]
  },
  "in all likelihood": {
    replace: ["probably"]
  },
  "in an effort to": {
    replace: ["to"]
  },
  "in between": {
    replace: ["between"]
  },
  "in excess of": {
    replace: ["more than"]
  },
  "in lieu of": {
    replace: ["instead"]
  },
  "in light of the fact that": {
    replace: ["because"]
  },
  "in many cases": {
    replace: ["often"]
  },
  "in order that": {
    replace: ["for", "so"]
  },
  "in order to": {
    replace: ["to"]
  },
  "in order for": {
    replace: ["for"]
  },
  "in regard to": {
    replace: ["about", "concerning", "on"]
  },
  "in relation to": {
    replace: ["about", "with", "to"]
  },
  "in some instances": {
    replace: ["sometimes"]
  },
  "in terms of": {
    omit: true,
    replace: ["as", "for", "with"]
  },
  "in the amount of": {
    replace: ["for"]
  },
  "in the event of": {
    replace: ["if"]
  },
  "in the near future": {
    replace: ["soon", "shortly"]
  },
  "in the process of": {
    omit: true,
    replace: []
  },
  "in view of": {
    replace: ["since"]
  },
  "in view of the above": {
    replace: ["so"]
  },
  "inasmuch as": {
    replace: ["since"]
  },
  inception: {
    replace: ["start"]
  },
  "incumbent upon": {
    replace: ["must"]
  },
  indicate: {
    replace: ["show", "say", "state", "write down"]
  },
  indication: {
    replace: ["sign"]
  },
  initial: {
    replace: ["first"]
  },
  initiate: {
    replace: ["start"]
  },
  "inter alia": {
    omit: true,
    replace: []
  },
  interface: {
    replace: ["meet", "work with"]
  },
  "interpose no objection": {
    replace: ["don\u2019t object"]
  },
  "is applicable to": {
    replace: ["applies to"]
  },
  "is authorised to": {
    replace: ["may"]
  },
  "is authorized to": {
    replace: ["may"]
  },
  "is in consonance with": {
    replace: ["agrees with", "follows"]
  },
  "is responsible for": {
    omit: true,
    replace: ["handles"]
  },
  "it appears": {
    replace: ["seems"]
  },
  "it is": {
    omit: true,
    replace: []
  },
  "it is essential": {
    replace: ["must", "need to"]
  },
  "it is requested": {
    replace: ["please"]
  },
  liaison: {
    replace: ["discussion"]
  },
  "limited number": {
    replace: ["limits"]
  },
  literally: {
    omit: true,
    replace: []
  },
  magnitude: {
    replace: ["size"]
  },
  maintain: {
    replace: ["support", "keep"]
  },
  maximum: {
    replace: ["greatest", "largest", "most"]
  },
  methodology: {
    replace: ["method"]
  },
  minimise: {
    replace: ["cut", "decrease"]
  },
  minimize: {
    replace: ["cut", "decrease"]
  },
  minimum: {
    replace: ["least", "small", "smallest"]
  },
  modify: {
    replace: ["change"]
  },
  monitor: {
    replace: ["check", "track", "watch"]
  },
  multiple: {
    replace: ["many"]
  },
  necessitate: {
    replace: ["cause", "need"]
  },
  nevertheless: {
    replace: ["besides", "even so", "still"]
  },
  "not certain": {
    replace: ["uncertain"]
  },
  "not many": {
    replace: ["few"]
  },
  "not often": {
    replace: ["rarely"]
  },
  "not unless": {
    replace: ["only if"]
  },
  "not unlike": {
    replace: ["alike", "similar"]
  },
  notify: {
    replace: ["let know", "tell"]
  },
  "not later than": {
    replace: ["by", "before"]
  },
  notwithstanding: {
    replace: ["despite", "in spite of", "still"]
  },
  "null and void": {
    replace: ["null", "void"]
  },
  numerous: {
    replace: ["many"]
  },
  objective: {
    replace: ["aim", "goal"]
  },
  obligate: {
    replace: ["bind", "compel"]
  },
  observe: {
    replace: ["see"]
  },
  obtain: {
    replace: ["get"]
  },
  "on the contrary": {
    replace: ["but", "so"]
  },
  "on the other hand": {
    omit: true,
    replace: ["but", "so"]
  },
  "one particular": {
    replace: ["one"]
  },
  operate: {
    replace: ["run", "use", "work"]
  },
  optimum: {
    replace: ["best", "greatest", "most"]
  },
  option: {
    replace: ["choice"]
  },
  overall: {
    omit: true,
    replace: []
  },
  "owing to the fact that": {
    replace: ["because", "since"]
  },
  parameters: {
    replace: ["limits"]
  },
  participate: {
    replace: ["take part"]
  },
  particulars: {
    replace: ["details"]
  },
  "pass away": {
    replace: ["die"]
  },
  perform: {
    replace: ["do"]
  },
  permit: {
    replace: ["let"]
  },
  "pertaining to": {
    replace: ["about", "of", "on"]
  },
  "point in time": {
    replace: ["moment", "now", "point", "time"]
  },
  portion: {
    replace: ["part"]
  },
  possess: {
    replace: ["have", "own"]
  },
  practicable: {
    replace: ["practical"]
  },
  preclude: {
    replace: ["prevent"]
  },
  previous: {
    replace: ["earlier"]
  },
  previously: {
    replace: ["before"]
  },
  "prior to": {
    replace: ["before"]
  },
  prioritise: {
    replace: ["focus on", "rank"]
  },
  prioritize: {
    replace: ["focus on", "rank"]
  },
  proceed: {
    replace: ["do", "go ahead", "try"]
  },
  procure: {
    omit: true,
    replace: ["buy", "get"]
  },
  proficiency: {
    replace: ["skill"]
  },
  promulgate: {
    replace: ["issue", "publish"]
  },
  provide: {
    replace: ["give", "offer", "say"]
  },
  "provided that": {
    replace: ["if"]
  },
  "provides guidance for": {
    replace: ["guides"]
  },
  purchase: {
    replace: ["buy", "sale"]
  },
  "pursuant to": {
    replace: ["by", "following", "per", "under"]
  },
  "put simply": {
    omit: true,
    replace: []
  },
  "readily apparent": {
    replace: ["clear"]
  },
  "refer back": {
    replace: ["refer"]
  },
  reflect: {
    replace: ["say", "show"]
  },
  regarding: {
    replace: ["about", "of", "on"]
  },
  "relative to": {
    replace: ["about", "on"]
  },
  relocate: {
    replace: ["move"]
  },
  remain: {
    replace: ["stay"]
  },
  remainder: {
    replace: ["rest"]
  },
  remuneration: {
    replace: ["pay", "payment"]
  },
  render: {
    replace: ["give", "make"]
  },
  represents: {
    replace: ["is"]
  },
  request: {
    replace: ["ask"]
  },
  require: {
    replace: ["must", "need"]
  },
  requirement: {
    replace: ["need", "rule"]
  },
  reside: {
    replace: ["live"]
  },
  residence: {
    replace: ["house"]
  },
  retain: {
    replace: ["keep"]
  },
  satisfy: {
    replace: ["meet", "please"]
  },
  selection: {
    replace: ["choice"]
  },
  "set forth in": {
    replace: ["in"]
  },
  shall: {
    replace: ["must", "will"]
  },
  "should you wish": {
    replace: ["if you want"]
  },
  "similar to": {
    replace: ["like"]
  },
  solicit: {
    replace: ["ask for", "request"]
  },
  "span across": {
    replace: ["cross", "span"]
  },
  "state-of-the-art": {
    replace: ["latest"]
  },
  strategise: {
    replace: ["plan"]
  },
  strategize: {
    replace: ["plan"]
  },
  submit: {
    replace: ["give", "send"]
  },
  subsequent: {
    replace: ["after", "later", "next", "then"]
  },
  subsequently: {
    replace: ["after", "later", "then"]
  },
  substantial: {
    replace: ["large", "much"]
  },
  "successfully complete": {
    replace: ["complete", "pass"]
  },
  sufficient: {
    replace: ["enough"]
  },
  "take action to": {
    omit: true,
    replace: []
  },
  terminate: {
    replace: ["end", "stop"]
  },
  "the month of": {
    omit: true,
    replace: []
  },
  "the undersigned": {
    replace: ["I"]
  },
  "the use of": {
    omit: true,
    replace: []
  },
  "there are": {
    omit: true,
    replace: []
  },
  "there is": {
    omit: true,
    replace: []
  },
  therefore: {
    replace: ["so", "thus"]
  },
  thereof: {
    replace: ["its", "their"]
  },
  therein: {
    replace: ["there"]
  },
  "this day and age": {
    replace: ["today"]
  },
  "time period": {
    replace: ["period", "time"]
  },
  timely: {
    replace: ["prompt"]
  },
  "took advantage of": {
    replace: ["preyed on"]
  },
  transmit: {
    replace: ["send"]
  },
  type: {
    omit: true,
    replace: []
  },
  transpire: {
    replace: ["happen"]
  },
  "under the provisions of": {
    replace: ["under"]
  },
  "until such time as": {
    replace: ["until"]
  },
  utilise: {
    replace: ["use"]
  },
  utilisation: {
    replace: ["use"]
  },
  utilization: {
    replace: ["use"]
  },
  utilize: {
    replace: ["use"]
  },
  validate: {
    replace: ["confirm"]
  },
  "various different": {
    replace: ["different", "various"]
  },
  very: {
    omit: true,
    replace: []
  },
  viable: {
    replace: ["practical", "workable"]
  },
  vice: {
    replace: ["instead of", "versus"]
  },
  warrant: {
    replace: ["call for", "permit"]
  },
  whereas: {
    replace: ["because", "since"]
  },
  "whether or not": {
    replace: ["whether"]
  },
  "with reference to": {
    replace: ["about"]
  },
  "with respect to": {
    replace: ["about", "on"]
  },
  "with the exception of": {
    replace: ["except for"]
  },
  witnessed: {
    replace: ["saw", "seen"]
  },
  "your office": {
    replace: ["you"]
  }
};

// node_modules/retext-simplify/index.js
var source3 = "retext-simplify";
var url4 = "https://github.com/retextjs/retext-simplify#readme";
var keys2 = Object.keys(patterns);
function retextSimplify(options = {}) {
  const ignore = options.ignore || [];
  const searches = ignore.length > 0 ? keys2.filter((d) => !ignore.includes(d)) : keys2;
  return (tree, file) => {
    search(tree, searches, (match, _, _1, phrase) => {
      const pattern = patterns[phrase];
      const actual = toString(match);
      const expected = pattern.replace;
      Object.assign(
        file.message(
          pattern.omit && expected.length === 0 ? "Remove " + quotation(actual, "`") : "Replace " + quotation(actual, "`") + " with " + quotation(expected, "`").join(", ") + (pattern.omit ? ", or remove it" : ""),
          { start: pointStart(match[0]), end: pointEnd(match[match.length - 1]) },
          [source3, phrase.replace(/\s+/g, "-").toLowerCase()].join(":")
        ),
        { actual, expected, url: url4 }
      );
    });
  };
}

// node_modules/retext-syntax-mentions/index.js
var genitive = /['’]s?$/i;
var gh = /^@(?:[a-z\d]{1,2}|[a-z\d][a-z\d-]{1,37}[a-z\d])(\/(?:[a-z\d]{1,2}|[a-z\d][a-z\d-]{1,37}[a-z\d]))?$/i;
var tw = /^@\w{1,15}$/i;
function retextSyntaxMentions(options = {}) {
  const style = options.style || "github";
  let styleRe;
  if (style === null || style === void 0 || style === "github") {
    styleRe = gh;
  } else if (style === "twitter") {
    styleRe = tw;
  } else if (typeof style === "object" && "exec" in style) {
    styleRe = style;
  } else {
    throw new Error(
      "Expected known style (`github`, `twitter`), not `" + style + "`"
    );
  }
  return (tree) => {
    visit(tree, "SymbolNode", (node, index2, parent_) => {
      const parent = (
        /** @type {Sentence|Word} */
        parent_
      );
      if (toString(node) !== "@" || !parent || index2 === null) {
        return;
      }
      const siblings = parent.children;
      let offset = index2 + 1;
      while (offset < siblings.length) {
        if (siblings[offset].type === "WhiteSpaceNode")
          break;
        if (toString(siblings[offset]) !== "/" && !check(siblings.slice(index2, offset + 1))) {
          break;
        }
        offset++;
      }
      const slice = siblings.slice(index2, offset);
      if (!check(slice)) {
        return;
      }
      const replacement = {
        type: "SourceNode",
        value: toString(slice),
        position: {
          start: pointStart(node),
          end: pointEnd(slice[slice.length - 1])
        }
      };
      siblings.splice(index2, offset - index2, replacement);
    });
  };
  function check(nodes) {
    return styleRe.test(toString(nodes).replace(genitive, ""));
  }
}

// node_modules/array-iterate/lib/index.js
var own5 = {}.hasOwnProperty;
function arrayIterate(values, callbackFn, thisArg) {
  let index2 = -1;
  if (!values) {
    throw new Error("Iterate requires that |this| not be " + values);
  }
  if (!own5.call(values, "length")) {
    throw new Error("Iterate requires that |this| has a `length`");
  }
  if (typeof callbackFn !== "function") {
    throw new TypeError("`callback` must be a function");
  }
  while (++index2 < values.length) {
    if (!(index2 in values)) {
      continue;
    }
    const result = callbackFn.call(thisArg, values[index2], index2, values);
    if (typeof result === "number") {
      if (result < 0) {
        index2 = 0;
      }
      index2 = result - 1;
    }
  }
}

// node_modules/unist-util-modify-children/lib/index.js
function modifyChildren(modifier) {
  return modify;
  function modify(parent) {
    if (!parent || !parent.children) {
      throw new Error("Missing children in `parent` for `modifier`");
    }
    arrayIterate(parent.children, iteratee, parent);
  }
  function iteratee(node, index2) {
    return modifier(node, index2, this);
  }
}

// node_modules/ccount/index.js
function ccount(value, character) {
  const source4 = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index2 = source4.indexOf(character);
  while (index2 !== -1) {
    count++;
    index2 = source4.indexOf(character, index2 + character.length);
  }
  return count;
}

// node_modules/retext-syntax-urls/index.js
var slashes = /^\/{1,3}$/;
function retextSyntaxUrls() {
  this.Parser.prototype.useFirst("tokenizeSentence", modifyChildren(mergeLinks));
  function mergeLinks(child, index2, parent) {
    const siblings = parent.children;
    let start = index2;
    let end = index2;
    const currentIndex = index2;
    const nodes = [child];
    const punc = toString(child);
    if (!(child.type === "PunctuationNode" || child.type === "SymbolNode") || punc !== "." && punc !== ":") {
      return;
    }
    let previous;
    while (previous = siblings[start - 1]) {
      if (!(previous.type === "WordNode" || previous.type === "PunctuationNode" || previous.type === "SymbolNode") || (previous.type === "PunctuationNode" || previous.type === "SymbolNode") && slashes.test(toString(previous))) {
        break;
      }
      start--;
      nodes.unshift(siblings[start]);
      if (previous.type === "WordNode" && toString(siblings[start]) === "www") {
        break;
      }
    }
    if (punc === ":" && toString(nodes) !== "localhost:") {
      return;
    }
    let next = siblings[end + 1];
    while (next && (next.type === "WordNode" || next.type === "PunctuationNode" || next.type === "SymbolNode")) {
      end++;
      nodes.push(next);
      next = siblings[end + 1];
    }
    if (currentIndex === start || currentIndex === end) {
      return;
    }
    previous = siblings[start - 1];
    if (previous && (previous.type === "PunctuationNode" || previous.type === "SymbolNode") && slashes.test(toString(previous))) {
      start--;
      nodes.unshift(siblings[start]);
    }
    previous = siblings[start - 1];
    if (previous && (previous.type === "PunctuationNode" || previous.type === "SymbolNode") && toString(previous) === ":" && siblings[start - 2].type === "WordNode") {
      nodes.unshift(siblings[start - 2], previous);
      start -= 2;
    }
    let value;
    if (siblings[end].type === "PunctuationNode" || siblings[end].type === "SymbolNode") {
      value = toString(siblings[end]);
      if (value === ")") {
        const value2 = toString(nodes);
        if (ccount(value2, "(") < ccount(value2, ")")) {
          end--;
          nodes.pop();
        }
      } else if (value !== "/") {
        end--;
        nodes.pop();
      }
    }
    if (toString(siblings.slice(index2 + 1, end + 1)).length === 1) {
      return;
    }
    const replacement = { type: "SourceNode", value: toString(nodes) };
    const initial = pointStart(nodes[0]);
    const final = pointEnd(nodes[nodes.length - 1]);
    if (initial.line && final.line) {
      replacement.position = { start: initial, end: final };
    }
    siblings.splice(start, end - start + 1, replacement);
    if (value === ".") {
      index2++;
    }
    return index2 + 1;
  }
}

// node_modules/unherit/index.js
function unherit(Super) {
  const Of = class extends Super {
  };
  const proto = Of.prototype;
  let key;
  for (key in proto) {
    const value = proto[key];
    if (value && typeof value === "object") {
      proto[key] = "concat" in value ? value.concat() : Object.assign({}, value);
    }
  }
  return Of;
}

// node_modules/parse-latin/lib/plugin/merge-initial-word-symbol.js
var mergeInitialWordSymbol = modifyChildren(function(child, index2, parent) {
  if (child.type !== "SymbolNode" && child.type !== "PunctuationNode" || toString(child) !== "&") {
    return;
  }
  const children = parent.children;
  const next = children[index2 + 1];
  if (index2 > 0 && children[index2 - 1].type === "WordNode" || !(next && next.type === "WordNode")) {
    return;
  }
  children.splice(index2, 1);
  next.children.unshift(child);
  if (next.position && child.position) {
    next.position.start = child.position.start;
  }
  return index2 - 1;
});

// node_modules/parse-latin/lib/plugin/merge-final-word-symbol.js
var mergeFinalWordSymbol = modifyChildren(function(child, index2, parent) {
  if (index2 > 0 && (child.type === "SymbolNode" || child.type === "PunctuationNode") && toString(child) === "-") {
    const children = parent.children;
    const previous = children[index2 - 1];
    const next = children[index2 + 1];
    if ((!next || next.type !== "WordNode") && previous && previous.type === "WordNode") {
      children.splice(index2, 1);
      previous.children.push(child);
      if (previous.position && child.position) {
        previous.position.end = child.position.end;
      }
      return index2;
    }
  }
});

// node_modules/parse-latin/lib/expressions.js
var affixSymbol = /^([!"').?\u00BB\u0F3B\u0F3D\u169C\u2019\u201D\u2026\u203A\u203D\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63\]}])\1*$/;
var newLine = /^[ \t]*((\r?\n|\r)[\t ]*)+$/;
var terminalMarker = /^([!.?\u2026\u203D]+)$/;
var wordSymbolInner = /^([&'\-.:=?@\u00AD\u00B7\u2010\u2011\u2019\u2027]|_+)$/;
var numerical = /^(?:[\d\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D58-\u0D5E\u0D66-\u0D78\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDD30-\uDD39\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54\uDFC5-\uDFCB]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2\uDD50-\uDD59]|\uD807[\uDC50-\uDC6C\uDD50-\uDD59\uDDA0-\uDDA9\uDFC0-\uDFD4]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9])+$/;
var digitStart = /^\d/;
var lowerInitial = /^(?:[a-z\u00B5\u00DF-\u00F6\u00F8-\u00FF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0560-\u0588\u10D0-\u10FA\u10FD-\u10FF\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7AF\uA7B5\uA7B7\uA7B9\uA7BB\uA7BD\uA7BF\uA7C3\uA7C8\uA7CA\uA7F6\uA7FA\uAB30-\uAB5A\uAB60-\uAB68\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43])/;
var surrogates = /[\uD800-\uDFFF]/;
var punctuation = /[!"'-),-/:;?[-\]_{}\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u201F\u2022-\u2027\u2032-\u203A\u203C-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
var word = /[\dA-Za-z\u00AA\u00B2\u00B3\u00B5\u00B9\u00BA\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u08D3-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09F4-\u09F9\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BF2\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7E\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D63\u0D66-\u0D78\u0D7A-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F33\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u17F0-\u17F9\u180B-\u180D\u1810-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1AC0\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u20D0-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA672\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA827\uA82C\uA830-\uA835\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE6\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD27\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEAB\uDEAC\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF54\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC52-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD47\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDCE-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E-\uDC61\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF3B]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD35\uDD37\uDD38\uDD3B-\uDD43\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3\uDFE4\uDFF0\uDFF1]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDD\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]|\uDB40[\uDD00-\uDDEF]/;
var whiteSpace = /[\t-\r \u0085\u00A0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

// node_modules/parse-latin/lib/plugin/merge-inner-word-symbol.js
var mergeInnerWordSymbol = modifyChildren(function(child, index2, parent) {
  if (index2 > 0 && (child.type === "SymbolNode" || child.type === "PunctuationNode")) {
    const siblings = parent.children;
    const previous = siblings[index2 - 1];
    if (previous && previous.type === "WordNode") {
      let position3 = index2 - 1;
      let tokens = [];
      let queue = [];
      while (siblings[++position3]) {
        const sibling = siblings[position3];
        if (sibling.type === "WordNode") {
          tokens = tokens.concat(queue, sibling.children);
          queue = [];
        } else if ((sibling.type === "SymbolNode" || sibling.type === "PunctuationNode") && wordSymbolInner.test(toString(sibling))) {
          queue.push(sibling);
        } else {
          break;
        }
      }
      if (tokens.length > 0) {
        if (queue.length > 0) {
          position3 -= queue.length;
        }
        siblings.splice(index2, position3 - index2);
        previous.children = previous.children.concat(tokens);
        const last = tokens[tokens.length - 1];
        if (previous.position && last.position) {
          previous.position.end = last.position.end;
        }
        return index2;
      }
    }
  }
});

// node_modules/parse-latin/lib/plugin/merge-inner-word-slash.js
var slash = "/";
var mergeInnerWordSlash = modifyChildren(function(child, index2, parent) {
  const siblings = parent.children;
  const previous = siblings[index2 - 1];
  const next = siblings[index2 + 1];
  if (previous && previous.type === "WordNode" && (child.type === "SymbolNode" || child.type === "PunctuationNode") && toString(child) === slash) {
    const previousValue = toString(previous);
    let tail = child;
    let queue = [child];
    let count = 1;
    let nextValue = "";
    if (next && next.type === "WordNode") {
      nextValue = toString(next);
      tail = next;
      queue = queue.concat(next.children);
      count++;
    }
    if (previousValue.length < 3 && (!nextValue || nextValue.length < 3)) {
      previous.children = previous.children.concat(queue);
      siblings.splice(index2, count);
      if (previous.position && tail.position) {
        previous.position.end = tail.position.end;
      }
      return index2;
    }
  }
});

// node_modules/parse-latin/lib/plugin/merge-initialisms.js
var mergeInitialisms = modifyChildren(function(child, index2, parent) {
  if (index2 > 0 && toString(child) === ".") {
    const siblings = parent.children;
    const previous = siblings[index2 - 1];
    const children = previous.children;
    if (previous.type === "WordNode" && children && children.length !== 1 && children.length % 2 !== 0) {
      let position3 = children.length;
      let isAllDigits = true;
      while (children[--position3]) {
        const otherChild = children[position3];
        const value = toString(otherChild);
        if (position3 % 2 === 0) {
          if (value.length > 1) {
            return;
          }
          if (!numerical.test(value)) {
            isAllDigits = false;
          }
        } else if (value !== ".") {
          if (position3 < children.length - 2) {
            break;
          } else {
            return;
          }
        }
      }
      if (!isAllDigits) {
        siblings.splice(index2, 1);
        children.push(child);
        if (previous.position && child.position) {
          previous.position.end = child.position.end;
        }
        return index2;
      }
    }
  }
});

// node_modules/parse-latin/lib/plugin/merge-words.js
var mergeWords = modifyChildren(function(child, index2, parent) {
  const siblings = parent.children;
  if (child.type === "WordNode") {
    const next = siblings[index2 + 1];
    if (next && next.type === "WordNode") {
      siblings.splice(index2 + 1, 1);
      child.children = child.children.concat(next.children);
      if (next.position && child.position) {
        child.position.end = next.position.end;
      }
      return index2;
    }
  }
});

// node_modules/unist-util-visit-children/lib/index.js
function visitChildren(visitor) {
  return visit2;
  function visit2(parent) {
    const children = parent && parent.children;
    let index2 = -1;
    if (!children) {
      throw new Error("Missing children in `parent` for `visit`");
    }
    while (++index2 in children) {
      visitor(children[index2], index2, parent);
    }
  }
}

// node_modules/parse-latin/lib/plugin/patch-position.js
var patchPosition = visitChildren(function(child, index2, node) {
  const siblings = node.children;
  if (!child.position) {
    return;
  }
  if (index2 < 1 && /* c8 ignore next */
  (!node.position || !node.position.start)) {
    patch(node);
    node.position.start = child.position.start;
  }
  if (index2 === siblings.length - 1 && (!node.position || !node.position.end)) {
    patch(node);
    node.position.end = child.position.end;
  }
});
function patch(node) {
  if (!node.position) {
    node.position = {};
  }
}

// node_modules/parse-latin/lib/plugin/merge-non-word-sentences.js
var mergeNonWordSentences = modifyChildren(function(child, index2, parent) {
  const children = child.children;
  let position3 = -1;
  while (children[++position3]) {
    if (children[position3].type === "WordNode") {
      return;
    }
  }
  const previous = parent.children[index2 - 1];
  if (previous) {
    previous.children = previous.children.concat(children);
    parent.children.splice(index2, 1);
    if (previous.position && child.position) {
      previous.position.end = child.position.end;
    }
    return index2;
  }
  const next = parent.children[index2 + 1];
  if (next) {
    next.children = children.concat(next.children);
    if (next.position && child.position) {
      next.position.start = child.position.start;
    }
    parent.children.splice(index2, 1);
  }
});

// node_modules/parse-latin/lib/plugin/merge-affix-symbol.js
var mergeAffixSymbol = modifyChildren(function(child, index2, parent) {
  const children = child.children;
  if (children && children.length > 0 && index2 > 0) {
    const first = children[0];
    const second = children[1];
    const previous = parent.children[index2 - 1];
    if ((first.type === "SymbolNode" || first.type === "PunctuationNode") && affixSymbol.test(toString(first))) {
      previous.children.push(children.shift());
      if (first.position && previous.position) {
        previous.position.end = first.position.end;
      }
      if (second && second.position && child.position) {
        child.position.start = second.position.start;
      }
      return index2 - 1;
    }
  }
});

// node_modules/parse-latin/lib/plugin/merge-initial-lower-case-letter-sentences.js
var mergeInitialLowerCaseLetterSentences = modifyChildren(function(child, index2, parent) {
  const children = child.children;
  if (children && children.length > 0 && index2 > 0) {
    let position3 = -1;
    while (children[++position3]) {
      const node = children[position3];
      if (node.type === "WordNode") {
        if (!lowerInitial.test(toString(node))) {
          return;
        }
        const siblings = parent.children;
        const previous = siblings[index2 - 1];
        previous.children = previous.children.concat(children);
        siblings.splice(index2, 1);
        if (previous.position && child.position) {
          previous.position.end = child.position.end;
        }
        return index2;
      }
      if (node.type === "SymbolNode" || node.type === "PunctuationNode") {
        return;
      }
    }
  }
});

// node_modules/parse-latin/lib/plugin/merge-initial-digit-sentences.js
var mergeInitialDigitSentences = modifyChildren(function(child, index2, parent) {
  const children = child.children;
  const siblings = parent.children;
  const previous = siblings[index2 - 1];
  const head = children[0];
  if (previous && head && head.type === "WordNode" && digitStart.test(toString(head))) {
    previous.children = previous.children.concat(children);
    siblings.splice(index2, 1);
    if (previous.position && child.position) {
      previous.position.end = child.position.end;
    }
    return index2;
  }
});

// node_modules/parse-latin/lib/plugin/merge-prefix-exceptions.js
var abbreviationPrefix = new RegExp(
  "^([0-9]{1,3}|[a-z]|al|ca|cap|cca|cent|cf|cit|con|cp|cwt|ead|etc|ff|fl|ibid|id|nem|op|pro|seq|sic|stat|tem|viz)$"
);
var mergePrefixExceptions = modifyChildren(function(child, index2, parent) {
  const children = child.children;
  if (children && children.length > 1) {
    const period = children[children.length - 1];
    if (period && toString(period) === ".") {
      const node = children[children.length - 2];
      if (node && node.type === "WordNode" && abbreviationPrefix.test(toString(node).toLowerCase())) {
        node.children.push(period);
        children.pop();
        if (period.position && node.position) {
          node.position.end = period.position.end;
        }
        const next = parent.children[index2 + 1];
        if (next) {
          child.children = children.concat(next.children);
          parent.children.splice(index2 + 1, 1);
          if (next.position && child.position) {
            child.position.end = next.position.end;
          }
          return index2 - 1;
        }
      }
    }
  }
});

// node_modules/parse-latin/lib/plugin/merge-affix-exceptions.js
var mergeAffixExceptions = modifyChildren(function(child, index2, parent) {
  const children = child.children;
  if (!children || children.length === 0 || index2 < 1) {
    return;
  }
  let position3 = -1;
  while (children[++position3]) {
    const node = children[position3];
    if (node.type === "WordNode") {
      return;
    }
    if (node.type === "SymbolNode" || node.type === "PunctuationNode") {
      const value = toString(node);
      if (value !== "," && value !== ";") {
        return;
      }
      const previousChild = parent.children[index2 - 1];
      previousChild.children = previousChild.children.concat(children);
      if (previousChild.position && child.position) {
        previousChild.position.end = child.position.end;
      }
      parent.children.splice(index2, 1);
      return index2;
    }
  }
});

// node_modules/parse-latin/lib/plugin/merge-remaining-full-stops.js
var mergeRemainingFullStops = visitChildren(function(child) {
  const children = child.children;
  let position3 = children.length;
  let hasFoundDelimiter = false;
  while (children[--position3]) {
    const grandchild = children[position3];
    if (grandchild.type !== "SymbolNode" && grandchild.type !== "PunctuationNode") {
      if (grandchild.type === "WordNode") {
        hasFoundDelimiter = true;
      }
      continue;
    }
    if (!terminalMarker.test(toString(grandchild))) {
      continue;
    }
    if (!hasFoundDelimiter) {
      hasFoundDelimiter = true;
      continue;
    }
    if (toString(grandchild) !== ".") {
      continue;
    }
    const previous = children[position3 - 1];
    const next = children[position3 + 1];
    if (previous && previous.type === "WordNode") {
      const nextNext = children[position3 + 2];
      if (next && nextNext && next.type === "WhiteSpaceNode" && toString(nextNext) === ".") {
        continue;
      }
      children.splice(position3, 1);
      previous.children.push(grandchild);
      if (grandchild.position && previous.position) {
        previous.position.end = grandchild.position.end;
      }
      position3--;
    } else if (next && next.type === "WordNode") {
      children.splice(position3, 1);
      next.children.unshift(grandchild);
      if (grandchild.position && next.position) {
        next.position.start = grandchild.position.start;
      }
    }
  }
});

// node_modules/parse-latin/lib/plugin/make-initial-white-space-siblings.js
var makeInitialWhiteSpaceSiblings = visitChildren(function(child, index2, parent) {
  const children = child.children;
  if (children && children.length > 0 && children[0].type === "WhiteSpaceNode") {
    parent.children.splice(index2, 0, children.shift());
    const next = children[0];
    if (next && next.position && child.position) {
      child.position.start = next.position.start;
    }
  }
});

// node_modules/parse-latin/lib/plugin/make-final-white-space-siblings.js
var makeFinalWhiteSpaceSiblings = modifyChildren(function(child, index2, parent) {
  const children = child.children;
  if (children && children.length > 0 && children[children.length - 1].type === "WhiteSpaceNode") {
    parent.children.splice(index2 + 1, 0, child.children.pop());
    const previous = children[children.length - 1];
    if (previous && previous.position && child.position) {
      child.position.end = previous.position.end;
    }
    return index2;
  }
});

// node_modules/parse-latin/lib/plugin/break-implicit-sentences.js
var breakImplicitSentences = modifyChildren(function(child, index2, parent) {
  if (child.type !== "SentenceNode") {
    return;
  }
  const children = child.children;
  let position3 = 0;
  while (++position3 < children.length - 1) {
    const node = children[position3];
    if (node.type !== "WhiteSpaceNode" || toString(node).split(/\r\n|\r|\n/).length < 3) {
      continue;
    }
    child.children = children.slice(0, position3);
    const insertion = {
      type: "SentenceNode",
      children: children.slice(position3 + 1)
    };
    const tail = children[position3 - 1];
    const head = children[position3 + 1];
    parent.children.splice(index2 + 1, 0, node, insertion);
    if (child.position && tail.position && head.position) {
      const end = child.position.end;
      child.position.end = tail.position.end;
      insertion.position = { start: head.position.start, end };
    }
    return index2 + 1;
  }
});

// node_modules/parse-latin/lib/plugin/remove-empty-nodes.js
var removeEmptyNodes = modifyChildren(function(child, index2, parent) {
  if ("children" in child && child.children.length === 0) {
    parent.children.splice(index2, 1);
    return index2;
  }
});

// node_modules/parse-latin/lib/tokenizer.js
function tokenizerFactory(childType, expression) {
  return tokenizer;
  function tokenizer(node) {
    const children = [];
    const tokens = node.children;
    const type = node.type;
    let index2 = -1;
    const lastIndex = tokens.length - 1;
    let start = 0;
    while (++index2 < tokens.length) {
      if (index2 === lastIndex || tokens[index2].type === childType && expression.test(toString(tokens[index2]))) {
        const first = tokens[start];
        const last = tokens[index2];
        const parent = { type, children: tokens.slice(start, index2 + 1) };
        if (first.position && last.position) {
          parent.position = {
            start: first.position.start,
            end: last.position.end
          };
        }
        children.push(parent);
        start = index2 + 1;
      }
    }
    return children;
  }
}

// node_modules/parse-latin/lib/parser.js
function parserFactory(options) {
  const type = options.type;
  const tokenizerProperty = options.tokenizer;
  const delimiter = options.delimiter;
  const tokenize = delimiter && tokenizerFactory(options.delimiterType, delimiter);
  return parser;
  function parser(value) {
    const children = this[tokenizerProperty](value);
    return { type, children: tokenize ? tokenize(children) : children };
  }
}

// node_modules/parse-latin/lib/index.js
var ParseLatin = class {
  constructor(doc, file) {
    const value = file || doc;
    this.doc = value ? String(value) : null;
  }
  // Run transform plugins for `key` on `nodes`.
  run(key, nodes) {
    const wareKey = key + "Plugins";
    const plugins = this[wareKey];
    let index2 = -1;
    if (plugins) {
      while (plugins[++index2]) {
        plugins[index2](nodes);
      }
    }
    return nodes;
  }
  // Easy access to the document parser. This additionally supports retext-style
  // invocation: where an instance is created for each file, and the file is given
  // on construction.
  parse(value) {
    return this.tokenizeRoot(value || this.doc);
  }
  // Transform a `value` into a list of `NLCSTNode`s.
  tokenize(value) {
    const tokens = [];
    if (value === null || value === void 0) {
      value = "";
    } else if (value instanceof String) {
      value = value.toString();
    }
    if (typeof value !== "string") {
      if ("length" in value && (!value[0] || value[0].type)) {
        return value;
      }
      throw new Error(
        "Illegal invocation: '" + value + "' is not a valid argument for 'ParseLatin'"
      );
    }
    if (!value) {
      return tokens;
    }
    const eater = this.position ? eat : noPositionEat;
    let index2 = 0;
    let offset = 0;
    let line = 1;
    let column = 1;
    let previous = "";
    let queue = "";
    let left;
    let right;
    let character;
    while (index2 < value.length) {
      character = value.charAt(index2);
      if (whiteSpace.test(character)) {
        right = "WhiteSpace";
      } else if (punctuation.test(character)) {
        right = "Punctuation";
      } else if (word.test(character)) {
        right = "Word";
      } else {
        right = "Symbol";
      }
      tick.call(this);
      previous = character;
      character = "";
      left = right;
      right = null;
      index2++;
    }
    tick.call(this);
    return tokens;
    function tick() {
      if (left === right && (left === "Word" || left === "WhiteSpace" || character === previous || surrogates.test(character))) {
        queue += character;
      } else {
        if (queue) {
          this["tokenize" + left](queue, eater);
        }
        queue = character;
      }
    }
    function eat(subvalue) {
      const pos = position3();
      update(subvalue);
      return apply;
      function apply(...input) {
        return pos(add(...input));
      }
    }
    function noPositionEat() {
      return add;
    }
    function add(node, parent) {
      if (parent) {
        parent.children.push(node);
      } else {
        tokens.push(node);
      }
      return node;
    }
    function position3() {
      const before = now();
      function patch2(node) {
        node.position = new Position(before);
        return node;
      }
      return patch2;
    }
    function update(subvalue) {
      let character2 = -1;
      let lastIndex = -1;
      offset += subvalue.length;
      while (++character2 < subvalue.length) {
        if (subvalue.charAt(character2) === "\n") {
          lastIndex = character2;
          line++;
        }
      }
      if (lastIndex < 0) {
        column += subvalue.length;
      } else {
        column = subvalue.length - lastIndex;
      }
    }
    function Position(start) {
      this.start = start;
      this.end = now();
    }
    function now() {
      return { line, column, offset };
    }
  }
};
ParseLatin.prototype.position = true;
ParseLatin.prototype.tokenizeSymbol = createTextFactory("Symbol");
ParseLatin.prototype.tokenizeWhiteSpace = createTextFactory("WhiteSpace");
ParseLatin.prototype.tokenizePunctuation = createTextFactory("Punctuation");
ParseLatin.prototype.tokenizeSource = createTextFactory("Source");
ParseLatin.prototype.tokenizeText = createTextFactory("Text");
ParseLatin.prototype.use = useFactory(function(context, key, plugins) {
  context[key] = context[key].concat(plugins);
});
ParseLatin.prototype.useFirst = useFactory(function(context, key, plugins) {
  context[key] = plugins.concat(context[key]);
});
pluggable(ParseLatin, "tokenizeWord", function(value, eat) {
  const add = (eat || noopEat)("");
  const parent = { type: "WordNode", children: [] };
  this.tokenizeText(value, eat, parent);
  return add(parent);
});
pluggable(
  ParseLatin,
  "tokenizeSentence",
  parserFactory({ type: "SentenceNode", tokenizer: "tokenize" })
);
pluggable(
  ParseLatin,
  "tokenizeParagraph",
  parserFactory({
    type: "ParagraphNode",
    delimiter: terminalMarker,
    delimiterType: "PunctuationNode",
    tokenizer: "tokenizeSentence"
  })
);
pluggable(
  ParseLatin,
  "tokenizeRoot",
  parserFactory({
    type: "RootNode",
    delimiter: newLine,
    delimiterType: "WhiteSpaceNode",
    tokenizer: "tokenizeParagraph"
  })
);
ParseLatin.prototype.use("tokenizeSentence", [
  mergeInitialWordSymbol,
  mergeFinalWordSymbol,
  mergeInnerWordSymbol,
  mergeInnerWordSlash,
  mergeInitialisms,
  mergeWords,
  patchPosition
]);
ParseLatin.prototype.use("tokenizeParagraph", [
  mergeNonWordSentences,
  mergeAffixSymbol,
  mergeInitialLowerCaseLetterSentences,
  mergeInitialDigitSentences,
  mergePrefixExceptions,
  mergeAffixExceptions,
  mergeRemainingFullStops,
  makeInitialWhiteSpaceSiblings,
  makeFinalWhiteSpaceSiblings,
  breakImplicitSentences,
  removeEmptyNodes,
  patchPosition
]);
ParseLatin.prototype.use("tokenizeRoot", [
  makeInitialWhiteSpaceSiblings,
  makeFinalWhiteSpaceSiblings,
  removeEmptyNodes,
  patchPosition
]);
function createTextFactory(type) {
  type += "Node";
  return createText;
  function createText(value, eat, parent) {
    if (value === null || value === void 0) {
      value = "";
    }
    return (eat || noopEat)(value)({ type, value: String(value) }, parent);
  }
}
function pluggable(Constructor, key, callback) {
  Constructor.prototype[key] = function(...input) {
    return this.run(key, callback.apply(this, input));
  };
}
function useFactory(callback) {
  return use;
  function use(key, plugins) {
    if (!(key in this)) {
      throw new Error(
        "Illegal Invocation: Unsupported `key` for `use(key, plugins)`. Make sure `key` is a supported function"
      );
    }
    if (!plugins) {
      return;
    }
    const wareKey = key + "Plugins";
    plugins = typeof plugins === "function" ? [plugins] : plugins.concat();
    if (!this[wareKey]) {
      this[wareKey] = [];
    }
    callback(this, wareKey, plugins);
  }
}
function noopAdd(node, parent) {
  if (parent) {
    parent.children.push(node);
  }
  return node;
}
function noopEat() {
  return noopAdd;
}

// node_modules/parse-english/index.js
var import_nlcst_to_string22 = __toESM(require_nlcst_to_string(), 1);
var import_unist_util_visit_children4 = __toESM(require_unist_util_visit_children(), 1);
var import_unist_util_modify_children17 = __toESM(require_unist_util_modify_children(), 1);
var ParseEnglish = class extends ParseLatin {
};
ParseEnglish.prototype.tokenizeSentencePlugins = [
  (0, import_unist_util_visit_children4.default)(mergeEnglishElisionExceptions)
].concat(ParseEnglish.prototype.tokenizeSentencePlugins);
ParseEnglish.prototype.tokenizeParagraphPlugins = [
  (0, import_unist_util_modify_children17.default)(mergeEnglishPrefixExceptions)
].concat(ParseEnglish.prototype.tokenizeParagraphPlugins);
var abbreviations = new RegExp(
  "^(inc|ltd|bbls?|cu|doz|fl|ft|gal|gr|gro|in|kt|lbs?|mi|oz|pt|qt|sq|tbsp|tsp|yds?|sec|min|hr|mon|tue|tues|wed|thu|thurs|fri|sat|sun|jan|feb|mar|apr|jun|jul|aug|sep|sept|oct|nov|dec)$"
  // Note: There's no `i` flag here because the value to test against should be
  // all lowercase!
);
var abbreviationsSensitive = new RegExp(
  "^(Mr|Mrs|Miss|Ms|Mss|Mses|Mlle|Mme|M|Messrs|Mmes|Jr|Sr|Snr|Dr|Mgr|Atty|Prof|Hon|Rev|Fr|Msgr|Sr|Br|St|Pres|Supt|Rep|Sen|Gov|Amb|Treas|Sec|Amd|Brig|Gen|Cdr|Col|Capt|Lt|Maj|Sgt|Po|Wo|Ph|Ave|Blvd|Mt|Rd|Bldgs?|Nat|Natl|Rt|Rte|Co|Pk|Sq|Dr|Pt|St|Ft|Pen|Terr|Hwy|Fwy|Pkwy|Ala|Ariz|Ark|Cal|Calif|Col|Colo|Conn|Del|Fla|Ga|Ida|Id|Ill|Ind|Ia|Kan|Kans|Ken|Ky|La|Me|Md|Mass|Mich|Minn|Miss|Mo|Mont|Neb|Nebr|Nev|Mex|Dak|Okla|Ok|Ore|Penna|Penn|Pa|Tenn|Tex|Ut|Vt|Va|Wash|Wis|Wisc|Wyo|Alta|Man|Ont|Qu\xE9|Que|Sask|Yuk|Beds|Berks|Bucks|Cambs|Ches|Corn|Cumb|Derbys|Derbs|Dev|Dor|Dur|Glos|Hants|Here|Heref|Herts|Hunts|Lancs|Leics|Lincs|Mx|Middx|Mddx|Norf|Northants|Northumb|Northd|Notts|Oxon|Rut|Shrops|Salop|Som|Staffs|Staf|Suff|Sy|Sx|Ssx|Warks|War|Warw|Westm|Wilts|Worcs|Yorks)$"
);
var elisionPrefix = new RegExp(
  "^(o|ol)$"
);
var elisionAffix = new RegExp(
  "^(im|er|em|cause|twas|tis|twere|\\d\\ds?)$"
);
var apostrophe = /^['\u2019]$/;
function mergeEnglishPrefixExceptions(sentence, index2, paragraph) {
  var children = sentence.children;
  var period = children[children.length - 1];
  var word2 = children[children.length - 2];
  var value;
  var next;
  if (period && (0, import_nlcst_to_string22.default)(period) === "." && word2 && word2.type === "WordNode") {
    value = (0, import_nlcst_to_string22.default)(word2);
    if (abbreviations.test(lower(value)) || abbreviationsSensitive.test(value)) {
      word2.children.push(period);
      children.pop();
      if (period.position && word2.position) {
        word2.position.end = period.position.end;
      }
      next = paragraph.children[index2 + 1];
      if (next) {
        sentence.children = children.concat(next.children);
        paragraph.children.splice(index2 + 1, 1);
        if (next.position && sentence.position) {
          sentence.position.end = next.position.end;
        }
        return index2 - 1;
      }
    }
  }
}
function mergeEnglishElisionExceptions(child, index2, sentence) {
  var siblings;
  var sibling;
  var other;
  var length;
  var value;
  if (child.type !== "PunctuationNode" && child.type !== "SymbolNode") {
    return;
  }
  siblings = sentence.children;
  length = siblings.length;
  value = (0, import_nlcst_to_string22.default)(child);
  if (value === "/") {
    sibling = siblings[index2 - 1];
    if (sibling && lower((0, import_nlcst_to_string22.default)(sibling)) === "w") {
      siblings.splice(index2, 1);
      sibling.children.push(child);
      if (sibling.position && child.position) {
        sibling.position.end = child.position.end;
      }
    }
  } else if (apostrophe.test(value)) {
    sibling = siblings[index2 - 1];
    if (index2 > 2 && index2 < length - 1 && sibling.type === "WordNode" && siblings[index2 - 2].type === "WhiteSpaceNode" && siblings[index2 + 1].type === "WhiteSpaceNode" && elisionPrefix.test(lower((0, import_nlcst_to_string22.default)(sibling)))) {
      siblings.splice(index2, 1);
      sibling.children.push(child);
      if (sibling.position && child.position) {
        sibling.position.end = child.position.end;
      }
      return;
    }
    if (index2 !== length - 1 && siblings[index2 + 1].type === "WordNode" && (index2 === 0 || siblings[index2 - 1].type !== "WordNode")) {
      sibling = siblings[index2 + 1];
      value = lower((0, import_nlcst_to_string22.default)(sibling));
      if (elisionAffix.test(value)) {
        siblings.splice(index2, 1);
        sibling.children = [child].concat(sibling.children);
        if (sibling.position && child.position) {
          sibling.position.start = child.position.start;
        }
      } else if (value === "n" && index2 < length - 2 && apostrophe.test((0, import_nlcst_to_string22.default)(siblings[index2 + 2]))) {
        other = siblings[index2 + 2];
        siblings.splice(index2, 1);
        siblings.splice(index2 + 1, 1);
        sibling.children = [child].concat(sibling.children, other);
        if (sibling.position) {
          if (child.position) {
            sibling.position.start = child.position.start;
          }
          if (other.position) {
            sibling.position.end = other.position.end;
          }
        }
      }
    }
  }
}
function lower(value) {
  return value.toLowerCase();
}

// node_modules/retext-english/lib/index.js
function retextEnglish() {
  Object.assign(this, { Parser: unherit(ParseEnglish) });
}

// node_modules/retext-english/index.js
var retext_english_default = retextEnglish;

// node_modules/retext-stringify/lib/index.js
function retextStringify() {
  Object.assign(this, { Compiler });
}
function Compiler(tree) {
  return toString(tree);
}

// node_modules/retext-stringify/index.js
var retext_stringify_default = retextStringify;

// src/settings/settingsTab.ts
var import_obsidian = require("obsidian");
var RedPenSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Show proofreader highlights by default").setDesc(
      "Show red pen proofreader highlights by default when Obsidian is loaded."
    ).addDropdown((c) => {
      c.addOption("show", "Show").addOption("hide", "Hide").setValue(this.plugin.settings.defaultVisibility).onChange(async (value) => {
        this.plugin.settings.defaultVisibility = value;
        await this.plugin.saveSettings();
        if (value) {
          document.body.addClass("show-red-pen");
        } else if (document.body.hasClass("show-red-pen")) {
          document.body.removeClass("show-red-pen");
        }
      });
    });
    new import_obsidian.Setting(containerEl).setName("Enable intensify highlights").setDesc("Highlight weak or passive writing.").addToggle((c) => {
      c.setValue(this.plugin.settings.checkIntensify).onChange(
        async (value) => {
          this.plugin.settings.checkIntensify = value;
          await this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("Enable passive highlights").setDesc("Highlight use of passive voice.").addToggle((c) => {
      c.setValue(this.plugin.settings.checkPassive).onChange(
        async (value) => {
          this.plugin.settings.checkPassive = value;
          await this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("Enable simplify highlights").setDesc("Highlight words that could be simplified.").addToggle((c) => {
      c.setValue(this.plugin.settings.checkSimplify).onChange(
        async (value) => {
          this.plugin.settings.checkSimplify = value;
          await this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("Enable readability highlights").setDesc("Highlight phrases that might be hard to read.").addToggle((c) => {
      c.setValue(this.plugin.settings.checkReadability).onChange(
        async (value) => {
          this.plugin.settings.checkReadability = value;
          await this.plugin.saveSettings();
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("Readability reading age").setDesc("Set the reading age when checking for readability.").addSlider((c) => {
      c.setValue(this.plugin.settings.readingAge).setLimits(6, 18, 1).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.readingAge = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Readability algorithm threshold").setDesc(
      "Set the number of algorithms that need to agree that a sentence is hard to read for the target age before it is highlighted."
    ).addSlider((c) => {
      c.setValue(this.plugin.settings.algorithmThreshold).setLimits(1, 7, 1).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.algorithmThreshold = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/settings/settingsData.ts
var DEFAULT_SETTINGS = {
  defaultVisibility: "show",
  readingAge: 12,
  algorithmThreshold: 4,
  checkIntensify: true,
  checkReadability: true,
  checkPassive: true,
  checkSimplify: true
};

// src/views/summaryView.ts
var import_obsidian2 = require("obsidian");
var RedPenSummaryView = class extends import_obsidian2.ItemView {
  constructor(leaf, settings) {
    super(leaf);
    this.settings = settings;
  }
  getViewType() {
    return "red-pen-summary";
  }
  getDisplayText() {
    return "Red Pen Summary";
  }
  async onOpen() {
    const sidebar = this.containerEl.children[1];
    sidebar.empty();
    sidebar.createEl("h2", { text: "Red Pen Summary" });
    const summary = sidebar.createDiv("red-pen-summary");
    if (this.settings.checkIntensify) {
      const intensify_text = summary.createEl("p").createSpan({
        cls: "red-pen-summary-intensify"
      });
      intensify_text.createSpan({
        attr: { id: "red-pen-intensify-count" },
        text: "0"
      });
      intensify_text.createSpan({
        text: " phrases that could be intensified."
      });
    }
    if (this.settings.checkPassive) {
      const passive_text = summary.createEl("p").createSpan({
        cls: "red-pen-summary-passive"
      });
      passive_text.createSpan({
        attr: { id: "red-pen-passive-count" },
        text: "0"
      });
      passive_text.createSpan({ text: " phrases that use passive voice." });
    }
    if (this.settings.checkReadability) {
      const readability_text = summary.createEl("p").createSpan({
        cls: "red-pen-summary-readability"
      });
      readability_text.createSpan({
        attr: { id: "red-pen-readability-count" },
        text: "0"
      });
      readability_text.createSpan({
        text: " phrases that are difficult to read."
      });
    }
    if (this.settings.checkSimplify) {
      const simplify_text = summary.createEl("p").createSpan({
        cls: "red-pen-summary-simplify"
      });
      simplify_text.createSpan({
        attr: { id: "red-pen-simplify-count" },
        text: "0"
      });
      simplify_text.createSpan({
        text: " phrases that could be simplified."
      });
    }
  }
  async onClose() {
  }
};
function populateSummary(summary) {
  let element = document.getElementById("red-pen-intensify-count");
  if (element) {
    const count = summary["retext-intensify"];
    if (count !== void 0) {
      element.innerText = String(count);
    } else {
      element.innerText = "0";
    }
  }
  element = document.getElementById("red-pen-readability-count");
  if (element) {
    const count = summary["retext-readability"];
    if (count !== void 0) {
      element.innerText = String(count);
    } else {
      element.innerText = "0";
    }
  }
  element = document.getElementById("red-pen-passive-count");
  if (element) {
    const count = summary["retext-passive"];
    if (count !== void 0) {
      element.innerText = String(count);
    } else {
      element.innerText = "0";
    }
  }
  element = document.getElementById("red-pen-simplify-count");
  if (element) {
    const count = summary["retext-simplify"];
    if (count !== void 0) {
      element.innerText = String(count);
    } else {
      element.innerText = "0";
    }
  }
}

// src/plugin/main.ts
var RedPenPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    console.log(`Red Pen v${this.manifest.version} loaded`);
    this.registerEditorExtension([highlight_field(this.settings)]);
    this.addSettingTab(new RedPenSettingsTab(this.app, this));
    this.registerView(
      "red-pen-summary",
      (leaf) => new RedPenSummaryView(leaf, this.settings)
    );
    if (this.settings.defaultVisibility === "show") {
      document.body.addClass("show-red-pen");
      this.activateView();
    }
    this.addCommand({
      id: "toggle-highlights",
      name: "Toggle Proofreader Highlights",
      callback: () => {
        if (document.body.hasClass("show-red-pen")) {
          document.body.removeClass("show-red-pen");
          this.deactivateView();
        } else {
          document.body.addClass("show-red-pen");
          this.activateView();
        }
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType("red-pen-summary");
    await this.app.workspace.getRightLeaf(false).setViewState({
      type: "red-pen-summary",
      active: true
    });
    if (this.app.workspace.getLeavesOfType("red-pen-summary").length > 0) {
      const summary_leaf = this.app.workspace.getLeavesOfType("red-pen-summary")[0];
      this.app.workspace.revealLeaf(summary_leaf);
    }
  }
  async deactivateView() {
    this.app.workspace.detachLeavesOfType("red-pen-summary");
  }
};
function highlight_field(settings) {
  return import_state.StateField.define({
    create(state) {
      return import_view.Decoration.none;
    },
    update(highlights, transaction) {
      var _a, _b;
      let processor = unified().use(retext_english_default).use(retextSyntaxMentions).use(retextSyntaxUrls);
      if (settings.checkReadability) {
        processor = processor.use(retextReadability, {
          age: settings.readingAge,
          threshold: settings.algorithmThreshold
        });
      }
      if (settings.checkIntensify) {
        processor = processor.use(retextIntensify);
      }
      if (settings.checkPassive) {
        processor = processor.use(retextPassive);
      }
      if (settings.checkSimplify) {
        processor = processor.use(retextSimplify);
      }
      processor = processor.use(retext_stringify_default);
      let new_highlights = highlights.map(transaction.changes);
      const updated_doc = transaction.newDoc.sliceString(0);
      const file = processor.processSync(updated_doc);
      const summary = {};
      for (const msg of file.messages) {
        if (!msg.source) {
          continue;
        }
        const start = ((_a = msg.position) == null ? void 0 : _a.start.offset) || 0;
        const end = ((_b = msg.position) == null ? void 0 : _b.end.offset) || 0;
        const new_class = pluginClass(msg.source);
        let skip = false;
        new_highlights.between(start, end, (start2, end2, value) => {
          if (value.class === new_class) {
            skip = true;
            return false;
          }
        });
        if (!skip) {
          new_highlights = new_highlights.update({
            add: [
              import_view.Decoration.mark({
                class: new_class
              }).range(start, end)
            ]
          });
        }
        if (summary.hasOwnProperty(msg.source)) {
          summary[msg.source] += 1;
        } else {
          summary[msg.source] = 1;
        }
      }
      populateSummary(summary);
      return new_highlights;
    },
    provide: (field) => import_view.EditorView.decorations.from(field)
  });
}
function pluginClass(name) {
  switch (name) {
    case "retext-intensify":
      return "red-pen-mark-intensify";
    case "retext-passive":
      return "red-pen-mark-passive";
    case "retext-readability":
      return "red-pen-mark-readability";
    case "retext-simplify":
      return "red-pen-mark-simplify";
    default:
      return "";
  }
}
/*! Bundled license information:

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
